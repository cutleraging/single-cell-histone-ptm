stat_cor() +
theme_Publication() +
labs(y = "Coefficient of Variation Squared",
x = "Log2(Mean Relative Abundance)",
color = "Protein") +
theme(legend.position = "right",
legend.direction = "vertical",
legend.margin=margin()) +
annotate("text", x = Inf, y = Inf, label = equation, hjust = 1.5, vjust = 5, size = 4, color = "black")
dev.off()
dir.create("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto/without_technical_variation/without_unmodified_peptidoforms/coefficient_of_variation")
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto/without_technical_variation/without_unmodified_peptidoforms/coefficient_of_variation")
# plot cv
df.plot <- bio.var.adj.no_unmod[order(bio.var.adj.no_unmod$cv.bio.adj, decreasing = TRUE),] # order
df.plot$ptm <- factor(df.plot$ptm,
levels = rev(df.plot$ptm))
pdf("MS1.ratio.log1p.batchCorrect_cv_all.pdf",
width = 6,
height = 6)
ggplot(df.plot, aes(x=ptm, y=cv.bio.adj, fill=mean.bio)) +
geom_bar(stat="identity", width=0.95, position = position_dodge(width=1)) +
geom_text(aes(label=ptm), vjust=0.5, hjust = -0.05, angle=0, position=position_dodge(width=1), size = 3) +
coord_flip() +
theme_Publication() +
#scale_fill_manual(values = protein_colors) +
scale_fill_distiller(palette = 'RdBu') +
labs(y = "Adjusted Coefficient of Variation",
x = "Histone PTM",
fill = "Mean\nRelative\nAbundance",
subtitle = "Without Technical Noise") +
theme(legend.position = "right",
legend.direction = "vertical",
legend.margin=margin(),
axis.text.y=element_blank(),
axis.ticks.y=element_blank(),
legend.title = element_text(size = 10)) +
scale_y_continuous(labels = scales::percent_format(accuracy = 1),
breaks = c(seq(0, 1.5, by = 0.25)),
limits = c(0, 1.1))
dev.off()
pdf("MS1.ratio.log1p.batchCorrect_cv_top_20.pdf",
width = 5,
height = 6)
ggplot(df.plot[1:20,], aes(x=ptm, y=cv.bio.adj, fill=mean.bio)) +
geom_bar(stat="identity", width=0.95, position = position_dodge(width=1)) +
geom_text(aes(label=ptm), vjust=0.5, hjust = -0.05, angle=0, position=position_dodge(width=1), size = 3) +
coord_flip() +
theme_Publication() +
#scale_fill_manual(values = protein_colors) +
scale_fill_distiller(palette = 'RdBu') +
labs(y = "Adjusted Coefficient of Variation",
x = "Histone PTM",
fill = "Mean\nRelative\nAbundance",
subtitle = "Without Technical Noise") +
theme(legend.position = "right",
legend.direction = "vertical",
legend.margin=margin(),
axis.text.y=element_blank(),
axis.ticks.y=element_blank(),
legend.title = element_text(size = 10)) +
scale_y_continuous(labels = scales::percent_format(accuracy = 1),
breaks = c(seq(0, 1.5, by = 0.25)),
limits = c(0, 1.1))
dev.off()
# heatmap
obj.filter.ratio.multi.sc.no_unmod.temp <- obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]][rownames(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]]) %in% df.plot$ptm,]
column_ha = HeatmapAnnotation(Replicate = obj.filter.ratio.multi.sc.no_unmod.temp$replicate,
"Total MS1" = obj.filter.ratio.multi.sc.no_unmod.temp$total.ms1,
col = list(Replicate = c("1" = brewer.pal(3, "Set1")[1],
"2" = brewer.pal(3, "Set1")[2],
"3" = brewer.pal(3, "Set1")[3])))
mat <- assay(obj.filter.ratio.multi.sc.no_unmod.temp, "MS1.ratio.log1p.batchCorrect")
mat <- mat[match(df.plot$ptm, rownames(mat)),]
# Scale each row to have mean 0 and standard deviation 1
mat.scaled <- t(scale(t(mat), scale = TRUE, center = FALSE))
row_ha = rowAnnotation("Adjusted CV" = anno_barplot(df.plot$cv.bio.adj))
pdf("MS1.ratio.log1p.batchCorrect_cv_heatmap.pdf",
width = 10,
height = 10)
Heatmap(mat.scaled,
top_annotation = column_ha,
right_annotation = row_ha,
heatmap_legend_param = list(title = "Scaled Relative Abundance"),
cluster_rows = FALSE,
cluster_columns = TRUE,
show_column_names = FALSE,
row_names_gp = gpar(fontsize = 10))
dev.off()
# cv vs mean
# model <- lm(cv.bio.adj ~ poly(mean.bio, 2, raw=TRUE), data=df.plot)
# coefficients <- coef(model)
# equation <- sprintf("y = %.2f + %.2f*x + %.2f*x^2",
#                     coefficients[1], coefficients[2], coefficients[3])
pdf("MS1.ratio.log1p.batchCorrect_mean_vs_cv.pdf",
width = 7,
height = 5)
ggplot(df.plot, aes(x = mean.bio, y = cv.bio.adj)) +
geom_point(aes(color = Protein.Name)) +
geom_smooth(method = "lm", color = "blue") +
stat_cor() +
theme_Publication() +
scale_color_manual(values = protein_colors) +
labs(y = "Adjusted Coefficient of Variation",
x = "Log1p Mean Relative Abundance",
color = "Protein") +
theme(legend.position = "right",
legend.direction = "vertical",
legend.margin=margin())
dev.off()
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
# Chunk 2
library(MultiAssayExperiment)
library(tidyr)
library(dplyr)
library(tibble)
library(ggplot2)
library(pheatmap)
library(ComplexHeatmap)
library(ggpubr)
library(reshape2)
library(PCAtools)
library(class)
library(cluster)
library(viridis)
library(boot)
library(EnhancedVolcano)
library(corrplot)
library(ggpubr)
library(RColorBrewer)
# Chunk 3
source("/Users/ronaldcutler/Dropbox\ (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/functions.R")
# Chunk 4
setwd("/Users/ronaldcutler/Dropbox\ (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-cell-classification/auto+nabut")
obj.filter.ratio.multi <- readRDS("obj.filter.ratio.multi.RDS")
## subset single cells
obj.filter.ratio.multi.sc <- obj.filter.ratio.multi[,obj.filter.ratio.multi$multiplier == 1]
ncol(obj.filter.ratio.multi.sc[["ptm.ratio"]])
# filter out unmodified
peptides <- rownames(obj.filter.ratio.multi.sc[["ptm.ratio"]])
peptides <- peptides[!(grepl("\\[un\\]", peptides) & !grepl("\\[(me|ac|me2|me3|su|hib)\\]", peptides))]
obj.filter.ratio.multi.sc.no_unmod <- obj.filter.ratio.multi.sc[rownames(obj.filter.ratio.multi.sc) %in% peptides,]
# make the histone ptms readable
rownames(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]]) <- ptm_readable_translation(rownames(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]]))
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/peptidoform")
# Compute the correlation matrix
cor.mat.control <- cor(t(assay(obj.filter.ratio.multi.sc.no_unmod[,obj.filter.ratio.multi.sc.no_unmod$condition.predict == "control"][["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect")),
method = "pearson")
# # Perform hierarchical clustering
# dist.mat <- dist(cor.mat.control)
# hc <- hclust(dist.mat)
# Calculate the p-values of the correlations
p.mat.contol <- cor.mtest(t(assay(obj.filter.ratio.multi.sc.no_unmod[,obj.filter.ratio.multi.sc.no_unmod$condition.predict == "control"][["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect")), conf.level = 0.95)$p
# Order the matrix according to hierarchical clustering
order.hc.control <- corrMatOrder(cor.mat.control,
order = "hclust")
cor.mat.control <- cor.mat.control[order.hc.control, order.hc.control]
p.mat.contol <- p.mat.contol[order.hc.control, order.hc.control]
diag(p.mat.contol) <- 1
# # set protein colors
# rowdata <- rowData(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]])
# rowdata$Protein.Name <- protein_readable_translation(rowdata$Protein.Name)
# rowdata <- rowdata[match(rownames(cor.mat.control), rownames(rowdata)),]
#
# # Reorder Protein.Names according to hierarchical clustering order
# rowdata <- rowdata[hc$order, ]
# Create a color vector matched to the reordered labels
#protein_color_map <- setNames(protein_colors, rowdata$Protein.Name)  # Ensure protein_color_map exists
# Output matrices
write.csv(cor.mat.control, "control.cor.mat.control.csv")
write.csv(p.mat.contol, "control.p.mat.csv")
# Plot correlation matrix
pdf("control_covariance_matrix.pdf", height = 10, width = 10)
corrplot(cor.mat.control,
mar = c(1, 1, 1, 1),
method = "color",
type = "lower",
order = "original",  # Ensure clustering order matches the row order used
tl.pos = "ld",
#tl.col = protein_colors[rowdata$Protein.Name],  # Apply color to labels based on row names
tl.col = "black",
col = COL2(diverging = c("RdBu"), n = 200),
tl.cex = 1,
tl.offset = 0.3,
p.mat = p.mat.contol,  # Add p-value matrix
sig.level = 0.05,  # Add significance level
insig = "blank",
diag = FALSE)  # Non-significant correlations are blank
dev.off()
pdf("control_covariance_matrix_pub.pdf", height = 10, width = 10)
corrplot(cor.mat.control,
method = "color",
type = "lower",
order = "original",  # Ensure clustering order matches the row order used
tl.pos = "l",
cl.pos = "n",
#tl.col = protein_colors[rowdata$Protein.Name],  # Apply color to labels based on row names
tl.col = "black",
col = COL2(diverging = c("RdBu"), n = 200),
tl.cex = 1,
tl.offset = 0.3,
p.mat = p.mat.contol,  # Add p-value matrix
sig.level = 0.05,  # Add significance level
insig = "blank",
diag = TRUE)  # Non-significant correlations are blank
dev.off()
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/peptidoform")
# Compute the correlation matrix
cor.mat.treat <- cor(t(assay(obj.filter.ratio.multi.sc.no_unmod[,obj.filter.ratio.multi.sc.no_unmod$condition.predict == "treat"][["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect")),
method = "pearson")
# # Perform hierarchical clustering
# dist.mat <- dist(cor.mat.treat)
# hc <- hclust(dist.mat)
# Calculate the p-values of the correlations
p.mat.treat <- cor.mtest(t(assay(obj.filter.ratio.multi.sc.no_unmod[,obj.filter.ratio.multi.sc.no_unmod$condition.predict == "treat"][["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect")), conf.level = 0.95)$p
# Order the matrix according to hierarchical clustering in control
cor.mat.treat <- cor.mat.treat[order.hc.control, order.hc.control]
p.mat.treat <- p.mat.treat[order.hc.control, order.hc.control]
diag(p.mat.treat) <- 1
# # set protein colors
# rowdata <- rowData(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]])
# rowdata$Protein.Name <- protein_readable_translation(rowdata$Protein.Name)
# rowdata <- rowdata[match(rownames(cor.mat.treat), rownames(rowdata)),]
#
# # Reorder Protein.Names according to hierarchical clustering order
# rowdata <- rowdata[hc$order, ]
# Create a color vector matched to the reordered labels
#protein_color_map <- setNames(protein_colors, rowdata$Protein.Name)  # Ensure protein_color_map exists
# Output matrices
write.csv(cor.mat.treat, "treat.cor.mat.treat.csv")
write.csv(p.mat.treat, "treat.p.mat.csv")
# Plot correlation matrix
pdf("treat_covariance_matrix.pdf", height = 10, width = 10)
corrplot(cor.mat.treat,
method = "color",
type = "upper",
order = "original",  # Ensure clustering order matches the row order used
tl.pos = "td",
#tl.col = protein_colors[rowdata$Protein.Name],  # Apply color to labels based on row names
tl.col = "black",
col = COL2(diverging = c("RdBu"), n = 200),
tl.cex = 1,
tl.offset = 0.3,
p.mat = p.mat.treat,  # Add p-value matrix
sig.level = 0.05,  # Add significance level
insig = "blank",
diag = FALSE)  # Non-significant correlations are blank
dev.off()
# this one has diaganols
pdf("treat_covariance_matrix_pub.pdf", height = 10, width = 10)
corrplot(cor.mat.treat,
method = "color",
type = "upper",
order = "original",  # Ensure clustering order matches the row order used
tl.pos = "t",
cl.pos = "n",
#tl.col = protein_colors[rowdata$Protein.Name],  # Apply color to labels based on row names
tl.col = "black",
col = COL2(diverging = c("RdBu"), n = 200),
tl.cex = 1,
tl.offset = 0.3,
p.mat = p.mat.treat,  # Add p-value matrix
sig.level = 0.05,  # Add significance level
insig = "blank",
diag = TRUE)  # Non-significant correlations are blank
dev.off()
# test if correlation matrices are significantly different
library(vegan)
mantel_test <- mantel(cor.mat.control, cor.mat.treat, permutations=10000)
mantel_test
write.csv(mantel_test, "treat_vs_control_cor.mat_mantel_test.csv")
mantel_test$statistic
mantel_test$signif
mantel_test
mantel_test$permutations
mantel_test$method
mantel_test <- mantel(cor.mat.control, cor.mat.treat, permutations=10000)
mantel_results <- data.frame(
Mantel_Statistic = mantel_test$statistic,
Significance = mantel_test$signif,
Method = mantel_test$method,
Number_of_Permutations = mantel_test$permutations
)
write.csv(mantel_test, "treat_vs_control_cor.mat_mantel_test.csv")
write.csv(mantel_results, "treat_vs_control_cor.mat_mantel_test.csv")
mantel_test
sum(p.mat.treat < 0.05)
sum(p < 0.05)
sum(p.mat.contol < 0.05)
?cor.mtest
mantel_results
mantel_test
dir.create("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/coefficient_of_variation")
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/coefficient_of_variation")
# get relative abundance
df <- assay(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect") %>%
as.data.frame() %>%
rownames_to_column("ptm") %>%
pivot_longer(
cols = -ptm, # This keeps the 'id' column fixed
names_to = "variable",
values_to = "value") %>%
group_by(ptm) %>%
summarize(mean = mean(value, na.rm = TRUE),
mean.log1p = log1p(mean),
cv = sd(value, na.rm = TRUE)/mean,
cv.squared = cv^2) %>%
merge(as.data.frame(rowData(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]])), by.x = "ptm", by.y = "row.names")
df$Protein.Name <- protein_readable_translation(df$Protein.Name)
df
df <- assay(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect") %>%
as.data.frame() %>%
rownames_to_column("ptm") %>%
pivot_longer(
cols = -ptm, # This keeps the 'id' column fixed
names_to = "variable",
values_to = "value")
df
control.cv <- assay(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect") %>%
as.data.frame() %>%
rownames_to_column("ptm")
control.cv
control.cv <- assay(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect") %>%
as.data.frame() %>%
rownames_to_column("ptm") %>%
pivot_longer(
cols = -ptm, # This keeps the 'id' column fixed
names_to = "variable",
values_to = "value")
control.cv
control.cv <- assay(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect") %>%
as.data.frame() %>%
rownames_to_column("ptm") %>%
pivot_longer(
cols = -ptm, # This keeps the 'id' column fixed
names_to = "variable",
values_to = "value") %>%
merge(as.data.frame(colData(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]])), by.x = "variable", by.y = "row.names")
control.cv
obj.filter.ratio.multi.sc[["ptm.ratio"]]
obj.filter.ratio.multi.sc[["ptm.ratio"]]$condition
obj.filter.ratio.multi$condition.predict
obj.filter.ratio.multi.sc$condition.predict
peptides <- rownames(obj.filter.ratio.multi.sc[["ptm.ratio"]])
peptides <- peptides[!(grepl("\\[un\\]", peptides) & !grepl("\\[(me|ac|me2|me3|su|hib)\\]", peptides))]
obj.filter.ratio.multi.sc.no_unmod <- obj.filter.ratio.multi.sc[rownames(obj.filter.ratio.multi.sc) %in% peptides,]
# filter out unmodified
peptides <- rownames(obj.filter.ratio.multi.sc[["ptm.ratio"]])
peptides <- peptides[!(grepl("\\[un\\]", peptides) & !grepl("\\[(me|ac|me2|me3|su|hib)\\]", peptides))]
obj.filter.ratio.multi.sc.no_unmod <- obj.filter.ratio.multi.sc[rownames(obj.filter.ratio.multi.sc) %in% peptides,]
# make the histone ptms readable
rownames(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]]) <- ptm_readable_translation(rownames(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]]))
control.cv <- assay(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect") %>%
as.data.frame() %>%
rownames_to_column("ptm") %>%
pivot_longer(
cols = -ptm, # This keeps the 'id' column fixed
names_to = "variable",
values_to = "value") %>%
merge(as.data.frame(colData(obj.filter.ratio.multi.sc.no_unmod)), by.x = "variable", by.y = "row.names") %>%
group_by(ptm) %>%
summarize(mean = mean(value, na.rm = TRUE),
mean.log1p = log1p(mean),
cv = sd(value, na.rm = TRUE)/mean,
cv.squared = cv^2) %>%
merge(as.data.frame(rowData(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]])), by.x = "ptm", by.y = "row.names")
obj.filter.ratio.multi.sc.no_unmod$condition.predictcontrol.cv <- assay(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect") %>%
as.data.frame() %>%
rownames_to_column("ptm") %>%
pivot_longer(
cols = -ptm, # This keeps the 'id' column fixed
names_to = "variable",
values_to = "value") %>%
merge(as.data.frame(colData(obj.filter.ratio.multi.sc.no_unmod)), by.x = "variable", by.y = "row.names") %>%
group_by(ptm, condition.predict)
control.cv <- assay(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect") %>%
as.data.frame() %>%
rownames_to_column("ptm") %>%
pivot_longer(
cols = -ptm, # This keeps the 'id' column fixed
names_to = "variable",
values_to = "value") %>%
merge(as.data.frame(colData(obj.filter.ratio.multi.sc.no_unmod)), by.x = "variable", by.y = "row.names")
control.cv
control.cv <- assay(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect") %>%
as.data.frame() %>%
rownames_to_column("ptm") %>%
pivot_longer(
cols = -ptm, # This keeps the 'id' column fixed
names_to = "variable",
values_to = "value") %>%
merge(as.data.frame(colData(obj.filter.ratio.multi.sc.no_unmod)), by.x = "variable", by.y = "row.names") %>%
group_by(condition.predict, ptm)
control.cv
control.cv <- assay(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect") %>%
as.data.frame() %>%
rownames_to_column("ptm") %>%
pivot_longer(
cols = -ptm, # This keeps the 'id' column fixed
names_to = "variable",
values_to = "value") %>%
merge(as.data.frame(colData(obj.filter.ratio.multi.sc.no_unmod)), by.x = "variable", by.y = "row.names") %>%
group_by(condition.predict, ptm) %>%
summarize(mean = mean(value, na.rm = TRUE),
cv = sd(value, na.rm = TRUE)/mean)
control.cv
df <- assay(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect") %>%
as.data.frame() %>%
rownames_to_column("ptm") %>%
pivot_longer(
cols = -ptm, # This keeps the 'id' column fixed
names_to = "variable",
values_to = "value") %>%
merge(as.data.frame(colData(obj.filter.ratio.multi.sc.no_unmod)), by.x = "variable", by.y = "row.names") %>%
group_by(condition.predict, ptm) %>%
summarize(mean = mean(value, na.rm = TRUE),
cv = sd(value, na.rm = TRUE)/mean)
head(df)
df$condition.predict <- factor(df$condition.predict,
levels = c("Control", "Treat"))
df$condition.predict
df <- assay(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect") %>%
as.data.frame() %>%
rownames_to_column("ptm") %>%
pivot_longer(
cols = -ptm, # This keeps the 'id' column fixed
names_to = "variable",
values_to = "value") %>%
merge(as.data.frame(colData(obj.filter.ratio.multi.sc.no_unmod)), by.x = "variable", by.y = "row.names") %>%
group_by(condition.predict, ptm) %>%
summarize(mean = mean(value, na.rm = TRUE),
cv = sd(value, na.rm = TRUE)/mean)
df$condition.predict <- factor(df$condition.predict,
levels = c("control", "treat"))
df
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/coefficient_of_variation")
df <- assay(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect") %>%
as.data.frame() %>%
rownames_to_column("ptm") %>%
pivot_longer(
cols = -ptm, # This keeps the 'id' column fixed
names_to = "variable",
values_to = "value") %>%
merge(as.data.frame(colData(obj.filter.ratio.multi.sc.no_unmod)), by.x = "variable", by.y = "row.names") %>%
group_by(condition.predict, ptm) %>%
summarize(mean = mean(value, na.rm = TRUE),
cv = sd(value, na.rm = TRUE)/mean)
df$condition.predict <- factor(df$condition.predict,
levels = c("control", "treat"))
pdf("treat_vs_control_cv.pdf",
height = 5,
width = 5)
ggplot(df, aes(x = condition.predict, y = cv, fill = condition.predict)) +
geom_violin() +
geom_boxplot(width=0.1, fill="white") +
theme_Publication() +
scale_fill_manual(values = c(control = "#317ec2",
treat = "#c03830"),
labels = c("Control",
"Treat")) +
labs(y = "Coefficient of Variation", fill = "Condition") +
theme(axis.title.x=element_blank(),
axis.text.x=element_blank(),
axis.ticks.x=element_blank()) +
stat_compare_means(aes(group = variable),
method = "t.test", # Choose the appropriate test
label = "p.signif",
label.x.npc = "center",
label.y.npc = "top",
hide.ns = FALSE,
vjust = 1.5,
size = 5)
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/coefficient_of_variation")
df <- assay(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect") %>%
as.data.frame() %>%
rownames_to_column("ptm") %>%
pivot_longer(
cols = -ptm, # This keeps the 'id' column fixed
names_to = "variable",
values_to = "value") %>%
merge(as.data.frame(colData(obj.filter.ratio.multi.sc.no_unmod)), by.x = "variable", by.y = "row.names") %>%
group_by(condition.predict, ptm) %>%
summarize(mean = mean(value, na.rm = TRUE),
cv = sd(value, na.rm = TRUE)/mean)
df$condition.predict <- factor(df$condition.predict,
levels = c("control", "treat"))
pdf("treat_vs_control_cv.pdf",
height = 5,
width = 5)
ggplot(df, aes(x = condition.predict, y = cv, fill = condition.predict)) +
geom_violin() +
geom_boxplot(width=0.1, fill="white") +
theme_Publication() +
scale_fill_manual(values = c(control = "#317ec2",
treat = "#c03830"),
labels = c("Control",
"Treat")) +
labs(y = "Coefficient of Variation", fill = "Condition") +
theme(axis.title.x=element_blank(),
axis.text.x=element_blank(),
axis.ticks.x=element_blank()) +
stat_compare_means(aes(group = condition.predict),
method = "t.test", # Choose the appropriate test
label = "p.signif",
label.x.npc = "center",
label.y.npc = "top",
hide.ns = FALSE,
vjust = 1.5,
size = 5)
dev.off()
nrow(obj.filter.ratio.multi.sc[["ptm.ratio"]])
nrow(obj.filter.ratio.multi[["ptm.ratio"]])
