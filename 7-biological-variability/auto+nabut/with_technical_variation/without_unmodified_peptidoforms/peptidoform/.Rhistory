df.plot <- df[order(df$cv.squared, decreasing = TRUE),] # order
df.plot$ptm <- factor(df.plot$ptm,
levels = rev(df.plot$ptm))
pdf("MS1.ratio.log1p.batchCorrect_cv2_all.pdf",
width = 6,
height = 5)
ggplot(df.plot, aes(x=ptm, y=cv.squared, fill=Protein.Name)) +
geom_bar(stat="identity", width=0.95, position = position_dodge(width=1)) +
geom_text(aes(label=ptm), vjust=0.5, hjust = -0.05, angle=0, position=position_dodge(width=1), size = 3) +
coord_flip() +
theme_Publication() +
scale_fill_manual(values = protein_colors) +
labs(y = "Coefficient of Variation Squared",
x = "Histone PTM",
fill = "Protein") +
theme(legend.position = "right",
legend.direction = "vertical",
legend.margin=margin(),
axis.text.y=element_blank(),
axis.ticks.y=element_blank()) +
ylim(c(0, 1.4))
dev.off()
pdf("MS1.ratio.log1p.batchCorrect_cv2_top_20.pdf",
width = 6,
height = 5)
ggplot(df.plot[1:20,], aes(x=ptm, y=cv.squared, fill=Protein.Name)) +
geom_bar(stat="identity", width=0.95, position = position_dodge(width=1)) +
geom_text(aes(label=ptm), vjust=0.5, hjust = -0.05, angle=0, position=position_dodge(width=1), size = 3) +
coord_flip() +
theme_Publication() +
scale_fill_manual(values = protein_colors) +
labs(y = "Coefficient of Variation Squared",
x = "Histone PTM",
fill = "Protein") +
theme(legend.position = "right",
legend.direction = "vertical",
legend.margin=margin(),
axis.text.y=element_blank(),
axis.ticks.y=element_blank())  +
ylim(c(0, 1.4))
dev.off()
# cv2 vs mean
model <- lm(cv.squared ~ poly(mean, 2, raw=TRUE), data=df)
coefficients <- coef(model)
equation <- sprintf("y = %.2f + %.2f*x + %.2f*x^2",
coefficients[1], coefficients[2], coefficients[3])
pdf("MS1.ratio.log1p.batchCorrect_mean_vs_cv2.pdf",
width = 7,
height = 5)
ggplot(df, aes(x = mean, y = cv.squared)) +
geom_point(aes(color = Protein.Name)) +
geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "blue") +
stat_cor() +
theme_Publication() +
labs(y = "Coefficient of Variation Squared",
x = "Mean Relative Abundance",
color = "Protein") +
theme(legend.position = "right",
legend.direction = "vertical",
legend.margin=margin()) +
annotate("text", x = Inf, y = Inf, label = equation, hjust = 1.5, vjust = 5, size = 4, color = "black")
dev.off()
# cv2 vs log2 mean
# model <- lm(cv.squared ~ poly(mean.log1p, 2, raw=TRUE), data=df)
# coefficients <- coef(model)
# equation <- sprintf("y = %.2f + %.2f*x + %.2f*x^2",
#                     coefficients[1], coefficients[2], coefficients[3])
# pdf("MS1.ratio.log1p.batchCorrect_mean.log1p_vs_cv2.pdf",
#     width = 7,
#     height = 5)
# ggplot(df, aes(x = mean.log1p, y = cv.squared)) +
#   geom_point(aes(color = Protein.Name)) +
#   geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "blue") +
#   stat_cor() +
#   theme_Publication() +
#   labs(y = "Coefficient of Variation Squared",
#        x = "Log2(Mean Relative Abundance)",
#        color = "Protein") +
#   theme(legend.position = "right",
#       legend.direction = "vertical",
#       legend.margin=margin()) +
#   annotate("text", x = Inf, y = Inf, label = equation, hjust = 1.5, vjust = 5, size = 4, color = "black")
# dev.off()
# Chunk 18
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/coefficient_of_variation")
df <- assay(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect") %>%
as.data.frame() %>%
rownames_to_column("ptm") %>%
pivot_longer(
cols = -ptm, # This keeps the 'id' column fixed
names_to = "variable",
values_to = "value") %>%
merge(as.data.frame(colData(obj.filter.ratio.multi.sc.no_unmod)), by.x = "variable", by.y = "row.names") %>%
group_by(condition.predict, ptm) %>%
summarize(mean = mean(value, na.rm = TRUE),
cv = sd(value, na.rm = TRUE)/mean)
df$condition.predict <- factor(df$condition.predict,
levels = c("control", "treat"))
pdf("treat_vs_control_cv.pdf",
height = 4,
width = 3)
ggplot(df, aes(x = condition.predict, y = cv, fill = condition.predict)) +
geom_violin() +
geom_boxplot(width=0.25, fill="white") +
theme_Publication() +
scale_fill_manual(values = c(control = "#317ec2",
treat = "#c03830"),
labels = c("Control",
"Treat")) +
labs(y = "Coefficient of Variation", fill = "Condition") +
# theme(axis.title.x=element_blank(),
#       axis.text.x=element_blank(),
#       axis.ticks.x=element_blank()) +
stat_compare_means(aes(group = condition.predict),
method = "t.test", # Choose the appropriate test
label = "p.format",
label.x.npc = "center",
label.y.npc = "top",
hide.ns = FALSE,
vjust = 1.5,
size = 5)
dev.off()
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/peptidoform")
# Compute the correlation matrix
cor.mat.control <- cor(t(assay(obj.filter.ratio.multi.sc.no_unmod[,obj.filter.ratio.multi.sc.no_unmod$condition.predict == "control"][["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect")),
method = "pearson")
# # Perform hierarchical clustering
# dist.mat <- dist(cor.mat.control)
# hc <- hclust(dist.mat)
# Calculate the p-values of the correlations
p.mat.contol <- cor.mtest(t(assay(obj.filter.ratio.multi.sc.no_unmod[,obj.filter.ratio.multi.sc.no_unmod$condition.predict == "control"][["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect")), conf.level = 0.95)$p
# Order the matrix according to hierarchical clustering
order.hc.control <- corrMatOrder(cor.mat.control,
order = "hclust")
cor.mat.control <- cor.mat.control[order.hc.control, order.hc.control]
p.mat.contol <- p.mat.contol[order.hc.control, order.hc.control]
diag(p.mat.contol) <- 1
# get just lower half of matrix for pvalues
p.mat.contol.lower <- p.mat.contol
p.mat.contol.lower[upper.tri(p.mat.contol.lower)] <- NA
p.mat.contol.lower
write.csv(p.mat.contol.lower, "control.p.mat.lower.csv", na = "")
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/peptidoform")
# Compute the correlation matrix
cor.mat.treat <- cor(t(assay(obj.filter.ratio.multi.sc.no_unmod[,obj.filter.ratio.multi.sc.no_unmod$condition.predict == "treat"][["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect")),
method = "pearson")
# # Perform hierarchical clustering
# dist.mat <- dist(cor.mat.treat)
# hc <- hclust(dist.mat)
# Calculate the p-values of the correlations
p.mat.treat <- cor.mtest(t(assay(obj.filter.ratio.multi.sc.no_unmod[,obj.filter.ratio.multi.sc.no_unmod$condition.predict == "treat"][["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect")), conf.level = 0.95)$p
# Order the matrix according to hierarchical clustering in control
cor.mat.treat <- cor.mat.treat[order.hc.control, order.hc.control]
p.mat.treat <- p.mat.treat[order.hc.control, order.hc.control]
diag(p.mat.treat) <- 1
# get just lower half of matrix for pvalues
p.mat.treat.upper <- p.mat.treat
p.mat.treat.upper[lower.tri(p.mat.treat.upper)] <- NA
# # set protein colors
# rowdata <- rowData(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]])
# rowdata$Protein.Name <- protein_readable_translation(rowdata$Protein.Name)
# rowdata <- rowdata[match(rownames(cor.mat.treat), rownames(rowdata)),]
#
# # Reorder Protein.Names according to hierarchical clustering order
# rowdata <- rowdata[hc$order, ]
# Create a color vector matched to the reordered labels
#protein_color_map <- setNames(protein_colors, rowdata$Protein.Name)  # Ensure protein_color_map exists
# Output matrices
write.csv(cor.mat.treat, "treat.cor.mat.treat.csv")
write.csv(p.mat.treat, "treat.p.mat.csv")
write.csv(p.mat.treat.upper, "control.p.mat.lower.csv", na = "")
# Plot correlation matrix
pdf("treat_covariance_matrix.pdf", height = 10, width = 10)
corrplot(cor.mat.treat,
method = "color",
type = "upper",
order = "original",  # Ensure clustering order matches the row order used
tl.pos = "td",
#tl.col = protein_colors[rowdata$Protein.Name],  # Apply color to labels based on row names
tl.col = "black",
col = rev(COL2(diverging = c("RdBu"), n = 200)),
tl.cex = 1,
tl.offset = 0.3,
p.mat = p.mat.treat,  # Add p-value matrix
sig.level = 0.05,  # Add significance level
insig = "blank",
diag = FALSE)  # Non-significant correlations are blank
dev.off()
# this one has diaganols
pdf("treat_covariance_matrix_pub.pdf", height = 10, width = 10)
corrplot(cor.mat.treat,
method = "color",
type = "upper",
order = "original",  # Ensure clustering order matches the row order used
tl.pos = "t",
cl.pos = "n",
#tl.col = protein_colors[rowdata$Protein.Name],  # Apply color to labels based on row names
tl.col = "black",
col = rev(COL2(diverging = c("RdBu"), n = 200)),
tl.cex = 1,
tl.offset = 0.3,
p.mat = p.mat.treat,  # Add p-value matrix
sig.level = 0.05,  # Add significance level
insig = "blank",
diag = TRUE)  # Non-significant correlations are blank
dev.off()
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/peptidoform")
# Compute the correlation matrix
cor.mat.control <- cor(t(assay(obj.filter.ratio.multi.sc.no_unmod[,obj.filter.ratio.multi.sc.no_unmod$condition.predict == "control"][["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect")),
method = "pearson")
# # Perform hierarchical clustering
# dist.mat <- dist(cor.mat.control)
# hc <- hclust(dist.mat)
# Calculate the p-values of the correlations
p.mat.contol <- cor.mtest(t(assay(obj.filter.ratio.multi.sc.no_unmod[,obj.filter.ratio.multi.sc.no_unmod$condition.predict == "control"][["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect")), conf.level = 0.95)$p
# Order the matrix according to hierarchical clustering
order.hc.control <- corrMatOrder(cor.mat.control,
order = "hclust")
cor.mat.control <- cor.mat.control[order.hc.control, order.hc.control]
p.mat.contol <- p.mat.contol[order.hc.control, order.hc.control]
diag(p.mat.contol) <- 1
# get just lower half of matrix for pvalues
p.mat.contol.lower <- p.mat.contol
p.mat.contol.lower[upper.tri(p.mat.contol.lower)] <- NA
# # set protein colors
# rowdata <- rowData(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]])
# rowdata$Protein.Name <- protein_readable_translation(rowdata$Protein.Name)
# rowdata <- rowdata[match(rownames(cor.mat.control), rownames(rowdata)),]
#
# # Reorder Protein.Names according to hierarchical clustering order
# rowdata <- rowdata[hc$order, ]
# Create a color vector matched to the reordered labels
#protein_color_map <- setNames(protein_colors, rowdata$Protein.Name)  # Ensure protein_color_map exists
# Output matrices
write.csv(cor.mat.control, "control.cor.mat.control.csv")
write.csv(p.mat.contol, "control.p.mat.csv")
write.csv(p.mat.contol.lower, "control.p.mat.lower.csv", na = "")
# Plot correlation matrix
pdf("control_covariance_matrix.pdf", height = 10, width = 10)
corrplot(cor.mat.control,
mar = c(1, 1, 1, 1),
method = "color",
type = "lower",
order = "original",  # Ensure clustering order matches the row order used
tl.pos = "ld",
#tl.col = protein_colors[rowdata$Protein.Name],  # Apply color to labels based on row names
tl.col = "black",
col = rev(COL2(diverging = c("RdBu"), n = 200)),
tl.cex = 1,
tl.offset = 0.3,
p.mat = p.mat.contol,  # Add p-value matrix
sig.level = 0.05,  # Add significance level
insig = "blank",
diag = FALSE)  # Non-significant correlations are blank
dev.off()
pdf("control_covariance_matrix_pub.pdf", height = 10, width = 10)
corrplot(cor.mat.control,
method = "color",
type = "lower",
order = "original",  # Ensure clustering order matches the row order used
tl.pos = "l",
cl.pos = "n",
#tl.col = protein_colors[rowdata$Protein.Name],  # Apply color to labels based on row names
tl.col = "black",
col = rev(COL2(diverging = c("RdBu"), n = 200)),
tl.cex = 1,
tl.offset = 0.3,
p.mat = p.mat.contol,  # Add p-value matrix
sig.level = 0.05,  # Add significance level
insig = "blank",
diag = TRUE)  # Non-significant correlations are blank
dev.off()
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/peptidoform")
# Compute the correlation matrix
cor.mat.treat <- cor(t(assay(obj.filter.ratio.multi.sc.no_unmod[,obj.filter.ratio.multi.sc.no_unmod$condition.predict == "treat"][["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect")),
method = "pearson")
# # Perform hierarchical clustering
# dist.mat <- dist(cor.mat.treat)
# hc <- hclust(dist.mat)
# Calculate the p-values of the correlations
p.mat.treat <- cor.mtest(t(assay(obj.filter.ratio.multi.sc.no_unmod[,obj.filter.ratio.multi.sc.no_unmod$condition.predict == "treat"][["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect")), conf.level = 0.95)$p
# Order the matrix according to hierarchical clustering in control
cor.mat.treat <- cor.mat.treat[order.hc.control, order.hc.control]
p.mat.treat <- p.mat.treat[order.hc.control, order.hc.control]
diag(p.mat.treat) <- 1
# get just lower half of matrix for pvalues
p.mat.treat.upper <- p.mat.treat
p.mat.treat.upper[lower.tri(p.mat.treat.upper)] <- NA
# # set protein colors
# rowdata <- rowData(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]])
# rowdata$Protein.Name <- protein_readable_translation(rowdata$Protein.Name)
# rowdata <- rowdata[match(rownames(cor.mat.treat), rownames(rowdata)),]
#
# # Reorder Protein.Names according to hierarchical clustering order
# rowdata <- rowdata[hc$order, ]
# Create a color vector matched to the reordered labels
#protein_color_map <- setNames(protein_colors, rowdata$Protein.Name)  # Ensure protein_color_map exists
# Output matrices
write.csv(cor.mat.treat, "treat.cor.mat.treat.csv")
write.csv(p.mat.treat, "treat.p.mat.csv")
write.csv(p.mat.treat.upper, "treat.p.mat.lower.csv", na = "")
# Plot correlation matrix
pdf("treat_covariance_matrix.pdf", height = 10, width = 10)
corrplot(cor.mat.treat,
method = "color",
type = "upper",
order = "original",  # Ensure clustering order matches the row order used
tl.pos = "td",
#tl.col = protein_colors[rowdata$Protein.Name],  # Apply color to labels based on row names
tl.col = "black",
col = rev(COL2(diverging = c("RdBu"), n = 200)),
tl.cex = 1,
tl.offset = 0.3,
p.mat = p.mat.treat,  # Add p-value matrix
sig.level = 0.05,  # Add significance level
insig = "blank",
diag = FALSE)  # Non-significant correlations are blank
dev.off()
# this one has diaganols
pdf("treat_covariance_matrix_pub.pdf", height = 10, width = 10)
corrplot(cor.mat.treat,
method = "color",
type = "upper",
order = "original",  # Ensure clustering order matches the row order used
tl.pos = "t",
cl.pos = "n",
#tl.col = protein_colors[rowdata$Protein.Name],  # Apply color to labels based on row names
tl.col = "black",
col = rev(COL2(diverging = c("RdBu"), n = 200)),
tl.cex = 1,
tl.offset = 0.3,
p.mat = p.mat.treat,  # Add p-value matrix
sig.level = 0.05,  # Add significance level
insig = "blank",
diag = TRUE)  # Non-significant correlations are blank
dev.off()
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/peptidoform")
# test if correlation matrices are significantly different
library(vegan)
mantel_test <- mantel(cor.mat.control, cor.mat.treat, permutations=10000)
mantel_results <- data.frame(
Mantel_Statistic = mantel_test$statistic,
Significance = mantel_test$signif,
Method = mantel_test$method,
Number_of_Permutations = mantel_test$permutations
)
write.csv(mantel_results, "treat_vs_control_cor.mat_mantel_test.csv")
# compute the fold difference matrix
cor.mat.fold <- log2((cor.mat.treat + 1) / (cor.mat.control + 1))
data_matrix <- assay(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect")
set.seed(123)  # Setting a seed for reproducibility
num_iterations <- 10000  # Number of times to perform the sampling
control_size <- 43    # Number of samples in the control group
treatment_size <- 29   # Number of samples in the treatment group
log2_fold_changes <- vector("list", num_iterations)
# Loop to perform the random sampling
for (i in 1:num_iterations) {
# Sample column indices randomly
sampled_indices <- sample(ncol(data_matrix), control_size + treatment_size)
# Split indices into control and treatment groups
control_indices <- sampled_indices[1:control_size]
treatment_indices <- sampled_indices[(control_size + 1):(control_size + treatment_size)]
# Extract the corresponding columns for control and treatment groups
control_matrix <- data_matrix[, control_indices]
treatment_matrix <- data_matrix[, treatment_indices]
# Calculate correlation matrices
control_cor <- cor(t(control_matrix))
treatment_cor <- cor(t(treatment_matrix))
# Calculate fold changes
log2_fold_changes[[i]] <- log2((treatment_cor + 1) / (control_cor + 1))
}
# Number of matrices in the list
num_matrices <- length(log2_fold_changes)
# Dimensions of one matrix (assuming all matrices are the same size)
num_rows <- nrow(log2_fold_changes[[1]])
num_cols <- ncol(log2_fold_changes[[1]])
# Initialize a matrix to store p-values
p_value_matrix <- matrix(0, num_rows, num_cols, dimnames = dimnames(log2_fold_changes[[1]]))
# Loop over each element in the matrix
for (i in 1:num_rows) {
for (j in 1:num_cols) {
# Collect the values from the same position across all matrices
null_distribution <- sapply(log2_fold_changes, function(x) x[i, j])
# Observed value at the same position
observed_value <- cor.mat.fold[i, j]
# Calculate two-sided p-value
extreme_high <- sum(null_distribution >= observed_value) / num_matrices
extreme_low <- sum(null_distribution <= observed_value) / num_matrices
p_value_matrix[i, j] <- 2 * min(extreme_high, extreme_low)
}
}
# Order the matrix according to hierarchical clustering in control
p_value_matrix <- p_value_matrix[order.hc.control, order.hc.control]
# get just lower half of matrix for log2FC
cor.mat.fold.upper <- cor.mat.fold
p.mat.treat.upper[lower.tri(p.mat.treat.upper)] <- NA
# get just lower half of matrix for pvalues
p.mat.fold.upper <- p_value_matrix
p.mat.fold.upper[lower.tri(p.mat.fold.upper)] <- NA
# Output matrices
write.csv(cor.mat.fold.upper, "treat_vs_control_log2fc.cor.mat.csv")
write.csv(p.mat.fold.upper, "treat_vs_control.p.mat.csv")
# Plot the difference matrix
pdf("treat_vs_control_foldChange_matrix.pdf",
height = 10,
width = 10)
corrplot(cor.mat.fold,
is.corr = FALSE,
method = "square",
type = "upper",
order = "original",
tl.pos = "td",
#tl.col = protein_colors[rowdata$Protein.Name],  # Apply color to labels based on row names
tl.col = "black",
col = rev(COL2(diverging = c("RdBu"), n = 200)),
col.lim = c(-2, 2),
tl.cex = 1,
tl.offset = 0.3,
p.mat = p_value_matrix,  # Add p-value matrix
sig.level = 0.05,  # Add significance level
insig = "blank",
diag = TRUE)
dev.off()
# Convert the matrix to a dataframe
cor.mat.fold.df <- melt(cor.mat.fold)
colnames(cor.mat.fold.df) <- c("PTM1", "PTM2", "Log2FoldChange")
cor.mat.fold.df$pvalue <- melt(p_value_matrix)$value
cor.mat.fold.df <- cor.mat.fold.df[order(cor.mat.fold.df$pvalue), ] # Sort by pvalue
write.csv(cor.mat.fold.df, "treat_vs_control.csv", row.names = FALSE)
# distribution of significant foldchanges
pdf("treat_vs_control_foldChange_distribution.pdf",
height = 4,
width = 4)
ggplot(subset(cor.mat.fold.df, pvalue < 0.05), aes(x=Log2FoldChange)) +
geom_histogram(colour="black", fill="white") +
theme_Publication() +
geom_vline(xintercept = 0,
linetype = "dashed",
color = "red") +
labs(x = "Log2 fold change",
y = "Frequency")
dev.off()
# compare significant pearon R
df <- melt(makePaddedDataFrame(list(Control = cor.mat.control[p.mat.contol < 0.05],
Treat = cor.mat.treat[p.mat.treat < 0.05])))
pdf("treat_vs_control_foldChange_R_values.pdf",
height = 4,
width = 3)
ggplot(df, aes(x = variable, y = value, fill = variable)) +
geom_violin() +
geom_boxplot(width=0.1, fill="white") +
theme_Publication() +
scale_fill_manual(values = c(Control = "#317ec2",
Treat = "#c03830")) +
labs(y = "Pairwise Euclidean Distance", fill = "Condition") +
stat_compare_means(aes(group = variable),
method = "t.test", # Choose the appropriate test
label = "p.signif",
label.x.npc = "center",
label.y.npc = "top",
hide.ns = FALSE,
vjust = 1.5,
size = 5)
dev.off()
cor.mat.fold.upper[lower.tri(cor.mat.fold.upper)] <- NA
# Output matrices
write.csv(cor.mat.fold.upper, "treat_vs_control_log2fc.cor.mat.csv")
write.csv(cor.mat.fold.upper, "treat_vs_control_log2fc.cor.mat.csv", na = "")
write.csv(p.mat.fold.upper, "treat_vs_control.p.mat.csv", na = "")
p_value_matrix
# multiple testing correction
# Flatten the matrix to a vector
p_values_vector <- as.vector(p_value_matrix)
# Adjust the p-values using the Benjamini-Hochberg method
adjusted_p_values_vector <- p.adjust(p_values_vector, method = "BH")
# Reshape the adjusted p-values vector back to a matrix
adjusted_p_values_matrix <- matrix(adjusted_p_values_vector, nrow = nrow(p_value_matrix), ncol = ncol(p_value_matrix))
# Assign row and column names to the adjusted p-values matrix
rownames(adjusted_p_values_matrix) <- rownames(p_value_matrix)
colnames(adjusted_p_values_matrix) <- colnames(p_value_matrix)
adjusted_p_values_matrix
adjusted_p_values_matrix
adjusted_p_values_vector
sum(adjusted_p_values_vector<0.05)
pdf("treat_vs_control_foldChange_matrix.pdf",
height = 10,
width = 10)
corrplot(cor.mat.fold,
is.corr = FALSE,
method = "square",
type = "upper",
order = "original",
tl.pos = "td",
#tl.col = protein_colors[rowdata$Protein.Name],  # Apply color to labels based on row names
tl.col = "black",
col = rev(COL2(diverging = c("RdBu"), n = 200)),
col.lim = c(-2, 2),
tl.cex = 1,
tl.offset = 0.3,
p.mat = adjusted_p_values_matrix,  # Add p-value matrix
sig.level = 0.05,  # Add significance level
insig = "blank",
diag = TRUE)
dev.off()
cor.mat.fold.upper <- cor.mat.fold
cor.mat.fold.upper[lower.tri(cor.mat.fold.upper)] <- NA
# get just lower half of matrix for pvalues
p.mat.fold.upper <- adjusted_p_values_matrix
p.mat.fold.upper[lower.tri(p.mat.fold.upper)] <- NA
# Output matrices
write.csv(cor.mat.fold.upper, "treat_vs_control_log2fc.cor.mat.csv", na = "")
write.csv(p.mat.fold.upper, "treat_vs_control.p.mat.csv", na = "")
