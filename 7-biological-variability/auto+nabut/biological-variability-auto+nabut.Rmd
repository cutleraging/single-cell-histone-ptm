---
title: "biological variability: auto+nabut"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Preparation

## Libraries
```{r}
library(MultiAssayExperiment)
library(tidyr)
library(dplyr)
library(tibble)
library(ggplot2)
library(pheatmap)
library(ComplexHeatmap)
library(ggpubr)
library(reshape2)
library(PCAtools)
library(class)
library(cluster)
library(viridis)
library(boot)
library(EnhancedVolcano)
library(corrplot)
library(ggpubr)
library(RColorBrewer)
```

## Functions
```{r}
source("/Users/ronaldcutler/Dropbox\ (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/functions.R")
```

## Load normalized data
```{r}
setwd("/Users/ronaldcutler/Dropbox\ (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-cell-classification/auto+nabut")

obj.filter.ratio.multi <- readRDS("obj.filter.ratio.multi.RDS")

## subset single cells
obj.filter.ratio.multi.sc <- obj.filter.ratio.multi[,obj.filter.ratio.multi$multiplier == 1]
ncol(obj.filter.ratio.multi.sc[["ptm.ratio"]])
```

# Cell-to-cell variation in peptidoforms - Both groups
- UPDATE TO DO COMPARISONS BETWEEN GROUPS

## With technical variation

### With unmodified peptidoforms

#### Peptidoform level

##### PCA
```{r}
dir.create("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation")
dir.create("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/with_unmodified_peptidoforms")
dir.create("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/with_unmodified_peptidoforms/pca")
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/with_unmodified_peptidoforms/pca")

p <- pca(t(assay(obj.filter.ratio.multi.sc[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect")),
         metadata = rowData(obj.filter.ratio.multi.sc[["ptm.ratio"]]),
         center = TRUE, 
         scale = TRUE)

pdf("MS1.ratio.log1p.batchCorrect_screeplot_peptidoform.pdf",
    width = 5,
    height = 5)
screeplot(p,
          components = getComponents(p)[1:10])
dev.off()

pdf("MS1.ratio.log1p.batchCorrect_eigencor_peptidoform.pdf",
    width = 5,
    height = 5)
eigencorplot(p,
             main = "Principle component correlations",
             cexMain = 1.5,
             metavars = c("Protein.Name", "Peptide.Sequence", "Precursor.Charge"),
             col = viridis(100),
             colCorval = 'firebrick',
             fontCorval = 2,
             cexCorval = 0.5,
             rotLabX = 45,
             posColKey = 'top')
dev.off()

pdf("MS1.ratio.log1p.batchCorrect_protein_pca_peptidoform.pdf",
    width = 7,
    height = 5)
biplot(p,
       colby = "Protein.Name", 
       hline = 0, 
       vline = 0,
       lab = NULL) +
  labs(color = "Protein") +
  theme_Publication() +
  theme(legend.position = "right",
        legend.direction = "vertical",
        legend.margin=margin())
dev.off()
```

##### Variance
- Positive relationship between variance and mean
- Log2 transform counts are more normally distributed
- polynomial regression when log transform counts
```{r}
dir.create("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/with_unmodified_peptidoforms/variance")
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/with_unmodified_peptidoforms/variance")

# get relative abundance
df <- assay(obj.filter.ratio.multi.sc[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect") %>%
  as.data.frame() %>%
  rownames_to_column("ptm") %>%
  pivot_longer(
    cols = -ptm, # This keeps the 'id' column fixed
    names_to = "variable",
    values_to = "value") %>%
  group_by(ptm) %>%
  summarize(mean = mean(value, na.rm = TRUE),
            mean.log1p = log1p(mean),
            variance = var(value, na.rm = TRUE),
            vmr = variance/mean) %>%
  merge(as.data.frame(rowData(obj.filter.ratio.multi.sc[["ptm.ratio"]])), by.x = "ptm", by.y = "row.names")
df$Protein.Name <- protein_readable_translation(df$Protein.Name)

# save
write.csv(df %>% select(-Fragment.Ions), 
          "MS1.ratio.log1p.batchCorrect_variance.csv",
          row.names = FALSE)

# plot variance
df.plot <- df[order(df$variance, decreasing = TRUE),] # order
df.plot$ptm <- factor(df.plot$ptm,
                      levels = rev(df.plot$ptm))

pdf("MS1.ratio.log1p.batchCorrect_variance_all.pdf",
    width = 6,
    height = 5)
ggplot(df.plot, aes(x=ptm, y=variance, fill=Protein.Name)) +
  geom_bar(stat="identity", width=0.95, position = position_dodge(width=1)) +
  geom_text(aes(label=ptm), vjust=0.5, hjust = -0.05, angle=0, position=position_dodge(width=1), size = 3) +
  coord_flip() +
  theme_Publication() +
  scale_fill_manual(values = protein_colors) +
  labs(y = "Variance",
       x = "Histone PTM",
       fill = "Protein") +
  theme(legend.position = "right",
      legend.direction = "vertical",
      legend.margin=margin(),
      axis.text.y=element_blank(),
      axis.ticks.y=element_blank())
dev.off()

pdf("MS1.ratio.log1p.batchCorrect_variance_top_20.pdf",
    width = 6,
    height = 5)
ggplot(df.plot[1:20,], aes(x=ptm, y=variance, fill=Protein.Name)) +
  geom_bar(stat="identity", width=0.95, position = position_dodge(width=1)) +
  geom_text(aes(label=ptm), vjust=0.5, hjust = -0.05, angle=0, position=position_dodge(width=1), size = 3) +
  coord_flip() +
  theme_Publication() +
  scale_fill_manual(values = protein_colors) +
  labs(y = "Variance",
       x = "Histone PTM",
       fill = "Protein") +
  theme(legend.position = "right",
      legend.direction = "vertical",
      legend.margin=margin(),
      axis.text.y=element_blank(),
      axis.ticks.y=element_blank())
dev.off()

# var vs mean
pdf("MS1.ratio.log1p.batchCorrect_mean_vs_variance.pdf",
    width = 7,
    height = 5)
ggplot(df, aes(x = mean, y = variance)) +
  geom_point(aes(color = Protein.Name)) +
  geom_smooth(method = "lm") +
  stat_cor() +
  theme_Publication() +
  labs(y = "Variance",
       x = "Mean Relative Abundance",
       color = "Protein") +
  theme(legend.position = "right",
      legend.direction = "vertical",
      legend.margin=margin())
dev.off()

# plot vmr
df.plot <- df[order(df$vmr, decreasing = TRUE),] # order
df.plot$ptm <- factor(df.plot$ptm,
                      levels = rev(df.plot$ptm))

pdf("MS1.ratio.log1p.batchCorrect_vmr_all.pdf",
    width = 6,
    height = 5)
ggplot(df.plot, aes(x=ptm, y=vmr, fill=Protein.Name)) +
  geom_bar(stat="identity", width=0.95, position = position_dodge(width=1)) +
  geom_text(aes(label=ptm), vjust=0.5, hjust = -0.05, angle=0, position=position_dodge(width=1), size = 3) +
  coord_flip() +
  theme_Publication() +
  scale_fill_manual(values = protein_colors) +
  labs(y = "Variance Mean Ratio",
       x = "Histone PTM",
       fill = "Protein") +
  theme(legend.position = "right",
      legend.direction = "vertical",
      legend.margin=margin(),
      axis.text.y=element_blank(),
      axis.ticks.y=element_blank())
dev.off()

pdf("MS1.ratio.log1p.batchCorrect_vmr_top_20.pdf",
    width = 6,
    height = 5)
ggplot(df.plot[1:20,], aes(x=ptm, y=vmr, fill=Protein.Name)) +
  geom_bar(stat="identity", width=0.95, position = position_dodge(width=1)) +
  geom_text(aes(label=ptm), vjust=0.5, hjust = -0.05, angle=0, position=position_dodge(width=1), size = 3) +
  coord_flip() +
  theme_Publication() +
  scale_fill_manual(values = protein_colors) +
  labs(y = "Variance Mean Ratio",
       x = "Histone PTM",
       fill = "Protein") +
  theme(legend.position = "right",
      legend.direction = "vertical",
      legend.margin=margin(),
      axis.text.y=element_blank(),
      axis.ticks.y=element_blank()) 
dev.off()

# vmr vs mean
pdf("MS1.ratio.log1p.batchCorrect_mean_vs_vmr.pdf",
    width = 7,
    height = 5)
ggplot(df, aes(x = mean, y = vmr)) +
  geom_point(aes(color = Protein.Name)) +
  geom_smooth(method = "lm") +
  stat_cor() +
  theme_Publication() +
  labs(y = "VMR",
       x = "Mean Relative Abundance",
       color = "Protein") +
  theme(legend.position = "right",
      legend.direction = "vertical",
      legend.margin=margin())
dev.off()

# var vs log2 mean
model <- lm(variance ~ poly(mean.log1p, 2, raw=TRUE), data=df)
coefficients <- coef(model)
equation <- sprintf("y = %.2f + %.2f*x + %.2f*x^2",
                    coefficients[1], coefficients[2], coefficients[3])
pdf("MS1.ratio.log1p.batchCorrect_mean.log1p_vs_variance.pdf",
    width = 7,
    height = 5)
ggplot(df, aes(x = mean.log1p, y = variance)) +
  geom_point(aes(color = Protein.Name)) +
  geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "blue") +
  stat_cor() +
  theme_Publication() +
  labs(y = "Variance",
       x = "Log2(Mean Relative Abundance)",
       color = "Protein") +
  theme(legend.position = "right",
      legend.direction = "vertical",
      legend.margin=margin()) +
  annotate("text", x = Inf, y = Inf, label = equation, hjust = 1.5, vjust = 5, size = 4, color = "black")
dev.off()

# vmr vs log2 mean
pdf("MS1.ratio.log1p.batchCorrect_mean.log1p_vs_vmr.pdf",
    width = 7,
    height = 5)
ggplot(df, aes(x = mean.log1p, y = vmr)) +
  geom_point(aes(color = Protein.Name)) +
  geom_smooth(method = "lm") +
  stat_cor() +
  theme_Publication() +
  labs(y = "VMR",
       x = "Log2(Mean Relative Abundance)",
       color = "Protein") +
  theme(legend.position = "right",
      legend.direction = "vertical",
      legend.margin=margin())
dev.off()
```

##### Coefficient of variation
- Inverse relationship between mean and CV^2
```{r}
dir.create("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/with_unmodified_peptidoforms/coefficient_of_variation")
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/with_unmodified_peptidoforms/coefficient_of_variation")

# get relative abundance
df <- assay(obj.filter.ratio.multi.sc[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect") %>%
  as.data.frame() %>%
  rownames_to_column("ptm") %>%
  pivot_longer(
    cols = -ptm, # This keeps the 'id' column fixed
    names_to = "variable",
    values_to = "value") %>%
  group_by(ptm) %>%
  summarize(mean = mean(value, na.rm = TRUE),
            mean.log1p = log1p(mean),
            cv = sd(value, na.rm = TRUE)/mean,
            cv.squared = cv^2) %>%
  merge(as.data.frame(rowData(obj.filter.ratio.multi.sc[["ptm.ratio"]])), by.x = "ptm", by.y = "row.names")
df$Protein.Name <- protein_readable_translation(df$Protein.Name)

# save
write.csv(df %>% select(-Fragment.Ions), 
          "MS1.ratio.log1p.batchCorrect_cv.csv",
          row.names = FALSE)

# plot cv
df.plot <- df[order(df$cv, decreasing = TRUE),] # order
df.plot$ptm <- factor(df.plot$ptm,
                      levels = rev(df.plot$ptm))

pdf("MS1.ratio.log1p.batchCorrect_cv_all.pdf",
    width = 6,
    height = 5)
ggplot(df.plot, aes(x=ptm, y=cv, fill=Protein.Name)) +
  geom_bar(stat="identity", width=0.95, position = position_dodge(width=1)) +
  geom_text(aes(label=ptm), vjust=0.5, hjust = -0.05, angle=0, position=position_dodge(width=1), size = 3) +
  coord_flip() +
  theme_Publication() +
  scale_fill_manual(values = protein_colors) +
  labs(y = "Coefficient of Variation",
       x = "Histone PTM",
       fill = "Protein") +
  theme(legend.position = "right",
      legend.direction = "vertical",
      legend.margin=margin(),
      axis.text.y=element_blank(),
      axis.ticks.y=element_blank())
dev.off()

pdf("MS1.ratio.log1p.batchCorrect_cv_top_20.pdf",
    width = 6,
    height = 5)
ggplot(df.plot[1:20,], aes(x=ptm, y=cv, fill=Protein.Name)) +
  geom_bar(stat="identity", width=0.95, position = position_dodge(width=1)) +
  geom_text(aes(label=ptm), vjust=0.5, hjust = -0.05, angle=0, position=position_dodge(width=1), size = 3) +
  coord_flip() +
  theme_Publication() +
  scale_fill_manual(values = protein_colors) +
  labs(y = "Coefficient of Variation",
       x = "Histone PTM",
       fill = "Protein") +
  theme(legend.position = "right",
      legend.direction = "vertical",
      legend.margin=margin(),
      axis.text.y=element_blank(),
      axis.ticks.y=element_blank())
dev.off()

# cv vs mean
model <- lm(cv ~ poly(mean, 2, raw=TRUE), data=df)
coefficients <- coef(model)
equation <- sprintf("y = %.2f + %.2f*x + %.2f*x^2",
                    coefficients[1], coefficients[2], coefficients[3])
pdf("MS1.ratio.log1p.batchCorrect_mean_vs_cv.pdf",
    width = 7,
    height = 5)
ggplot(df, aes(x = mean, y = cv)) +
  geom_point(aes(color = Protein.Name)) +
  geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "blue") +
  stat_cor() +
  theme_Publication() +
  labs(y = "Coefficient of Variation",
       x = "Mean Relative Abundance",
       color = "Protein") +
  theme(legend.position = "right",
      legend.direction = "vertical",
      legend.margin=margin()) +
  annotate("text", x = Inf, y = Inf, label = equation, hjust = 1.5, vjust = 5, size = 4, color = "black")
dev.off()

# plot cv2
df.plot <- df[order(df$cv.squared, decreasing = TRUE),] # order
df.plot$ptm <- factor(df.plot$ptm,
                      levels = rev(df.plot$ptm))

pdf("MS1.ratio.log1p.batchCorrect_cv2_all.pdf",
    width = 6,
    height = 5)
ggplot(df.plot, aes(x=ptm, y=cv.squared, fill=Protein.Name)) +
  geom_bar(stat="identity", width=0.95, position = position_dodge(width=1)) +
  geom_text(aes(label=ptm), vjust=0.5, hjust = -0.05, angle=0, position=position_dodge(width=1), size = 3) +
  coord_flip() +
  theme_Publication() +
  scale_fill_manual(values = protein_colors) +
  labs(y = "Coefficient of Variation Squared",
       x = "Histone PTM",
       fill = "Protein") +
  theme(legend.position = "right",
      legend.direction = "vertical",
      legend.margin=margin(),
      axis.text.y=element_blank(),
      axis.ticks.y=element_blank())
dev.off()

pdf("MS1.ratio.log1p.batchCorrect_cv2_top_20.pdf",
    width = 6,
    height = 5)
ggplot(df.plot[1:20,], aes(x=ptm, y=cv.squared, fill=Protein.Name)) +
  geom_bar(stat="identity", width=0.95, position = position_dodge(width=1)) +
  geom_text(aes(label=ptm), vjust=0.5, hjust = -0.05, angle=0, position=position_dodge(width=1), size = 3) +
  coord_flip() +
  theme_Publication() +
  scale_fill_manual(values = protein_colors) +
  labs(y = "Coefficient of Variation Squared",
       x = "Histone PTM",
       fill = "Protein") +
  theme(legend.position = "right",
      legend.direction = "vertical",
      legend.margin=margin(),
      axis.text.y=element_blank(),
      axis.ticks.y=element_blank()) 
dev.off()

# cv2 vs mean
model <- lm(cv.squared ~ poly(mean, 2, raw=TRUE), data=df)
coefficients <- coef(model)
equation <- sprintf("y = %.2f + %.2f*x + %.2f*x^2",
                    coefficients[1], coefficients[2], coefficients[3])
pdf("MS1.ratio.log1p.batchCorrect_mean_vs_cv2.pdf",
    width = 7,
    height = 5)
ggplot(df, aes(x = mean, y = cv.squared)) +
  geom_point(aes(color = Protein.Name)) +
  geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "blue") +
  stat_cor() +
  theme_Publication() +
  labs(y = "Coefficient of Variation Squared",
       x = "Mean Relative Abundance",
       color = "Protein") +
  theme(legend.position = "right",
      legend.direction = "vertical",
      legend.margin=margin()) +
  annotate("text", x = Inf, y = Inf, label = equation, hjust = 1.5, vjust = 5, size = 4, color = "black")
dev.off()

# cv vs log2 mean
# model <- lm(cv.squared ~ poly(mean.log1p, 2, raw=TRUE), data=df)
# coefficients <- coef(model)
# equation <- sprintf("y = %.2f + %.2f*x + %.2f*x^2",
#                     coefficients[1], coefficients[2], coefficients[3])
# pdf("MS1.ratio.log1p.batchCorrect_mean.log1p_vs_cv.pdf",
#     width = 7,
#     height = 5)
# ggplot(df, aes(x = mean.log1p, y = cv)) +
#   geom_point(aes(color = Protein.Name)) +
#   geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "blue") +
#   stat_cor() +
#   theme_Publication() +
#   labs(y = "Coefficient of Variation",
#        x = "Log2(Mean Relative Abundance)",
#        color = "Protein") +
#   theme(legend.position = "right",
#       legend.direction = "vertical",
#       legend.margin=margin())+
#   annotate("text", x = Inf, y = Inf, label = equation, hjust = 1.5, vjust = 5, size = 4, color = "black")
# dev.off()

# cv2 vs log2 mean
# model <- lm(cv.squared ~ poly(mean.log1p, 2, raw=TRUE), data=df)
# coefficients <- coef(model)
# equation <- sprintf("y = %.2f + %.2f*x + %.2f*x^2",
#                     coefficients[1], coefficients[2], coefficients[3])
# pdf("MS1.ratio.log1p.batchCorrect_mean.log1p_vs_cv2.pdf",
#     width = 7,
#     height = 5)
# ggplot(df, aes(x = mean.log1p, y = cv.squared)) +
#   geom_point(aes(color = Protein.Name)) +
#   geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "blue") +
#   stat_cor() +
#   theme_Publication() +
#   labs(y = "Coefficient of Variation Squared",
#        x = "Log2(Mean Relative Abundance)",
#        color = "Protein") +
#   theme(legend.position = "right",
#       legend.direction = "vertical",
#       legend.margin=margin()) +
#   annotate("text", x = Inf, y = Inf, label = equation, hjust = 1.5, vjust = 5, size = 4, color = "black")
# dev.off()
```

##### Beta regession
- Beta regression is particularly well-suited for modeling data that are bounded between 0 and 1, such as proportions, percentages, and relative abundances. This statistical method assumes that the dependent variable is distributed according to a Beta distribution, which can handle the typical skewness and heteroscedasticity observed in bounded data more effectively than traditional linear regression.
- It does not look like this model apprpriate fits the data
```{r, eval = FALSE}
dir.create("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/with_unmodified_peptidoforms/beta_regression")
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/with_unmodified_peptidoforms/beta_regression")

# get relative abundance
df <- assay(obj.filter.ratio.multi.sc[["ptm.ratio"]], "MS1.ratio.log1p") %>%
  as.data.frame() %>%
  rownames_to_column("ptm") %>%
  pivot_longer(
    cols = -ptm, # This keeps the 'id' column fixed
    names_to = "variable",
    values_to = "value") %>%
  merge(as.data.frame(colData(obj.filter.ratio.multi.sc)), by.x = "variable", by.y = "row.names")


# check if values are between 0-1
range(df$value)

# Fit beta regression
# including batch as a fixed effect - systematic effects
model <- betareg(value ~ 1 + ptm + replicate, data = df) 
summary(model)

# Plotting fitted values vs. residuals
# should be randomly distributed
df$residuals <- residuals(model, type = "pearson")

pdf("MS1.ratio.log1p.batchCorrect_beta_regression_residuals.pdf",
    width = 5,
    height = 5)
ggplot(df, aes(x = fitted(model), y = residuals)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  labs(title = "Residuals vs. Fitted", x = "Fitted Values", y = "Residuals")
dev.off()

# Checking normality of residuals
pdf("MS1.ratio.log1p.batchCorrect_beta_distribution_residuals.pdf",
    width = 5,
    height = 5)
hist(residuals(model, type = "pearson"), breaks = 20, main = "Histogram of Residuals")
dev.off()

# Generating a Q-Q plot for residuals
pdf("MS1.ratio.log1p.batchCorrect_beta_regression_qq.pdf",
    width = 5,
    height = 5)
qqnorm(df$residuals)
qqline(df$residuals, col = "steelblue")
dev.off()
```

##### Linear regession
- It looks like this model fits the data a bit better
```{r, eval = FALSE}
dir.create("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/with_unmodified_peptidoforms/linear_regression")
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/with_unmodified_peptidoforms/linear_regression")

# get relative abundance
df <- assay(obj.filter.ratio.multi.sc[["ptm.ratio"]], "MS1.ratio") %>%
  as.data.frame() %>%
  rownames_to_column("ptm") %>%
  pivot_longer(
    cols = -ptm, # This keeps the 'id' column fixed
    names_to = "variable",
    values_to = "value") %>%
  merge(as.data.frame(colData(obj.filter.ratio.multi.sc)), by.x = "variable", by.y = "row.names")


# check if values are between 0-1
range(df$value)

# Fit beta regression
# including batch as a fixed effect - systematic effects
model <- glm(log2(value) ~ ptm + replicate, data = df) 
summary(model)

# Plotting fitted values vs. residuals
# should be randomly distributed
df$residuals <- residuals(model, type = "pearson")

pdf("MS1.ratio.log1p.batchCorrect_linear_regression_residuals.pdf",
    width = 5,
    height = 5)
ggplot(df, aes(x = fitted(model), y = residuals)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  labs(title = "Residuals vs. Fitted", x = "Fitted Values", y = "Residuals")
dev.off()

# Checking normality of residuals
pdf("MS1.ratio.log1p.batchCorrect_linear_distribution_residuals.pdf",
    width = 5,
    height = 5)
hist(residuals(model, type = "pearson"), breaks = 20, main = "Histogram of Residuals")
dev.off()

# Generating a Q-Q plot for residuals
pdf("MS1.ratio.log1p.batchCorrect_linear_regression_qq.pdf",
    width = 5,
    height = 5)
qqnorm(df$residuals)
qqline(df$residuals, col = "steelblue")
dev.off()

ptm_variability <- df %>%
  group_by(ptm) %>%
  summarise(
    Mean_Residual = mean(residuals),
    SD_Residual = sd(residuals),
    Count = n()
  ) %>%
  arrange(desc(SD_Residual))

# plot
# coefficients <- coef(model)
# equation <- sprintf("y = %.2f + %.2f*x + %.2f*x^2",
#                     coefficients[1], coefficients[2], coefficients[3])
pdf("MS1.ratio.log1p.batchCorrect_linear_regression_mean_vs_residual.pdf",
    width = 7,
    height = 5)
ggplot(ptm_variability, aes(x = Mean_Residual, y = SD_Residual)) +
  geom_point() +
  geom_smooth(method = "lm") +
  stat_cor() +
  theme_Publication() +
  labs(y = "Residual",
       x = "Mean",
       color = "Protein") +
  theme(legend.position = "right",
      legend.direction = "vertical",
      legend.margin=margin()) 
dev.off()
```

##### PTM-PTM covariance
```{r}
dir.create("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/with_unmodified_peptidoforms/covariance")
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/with_unmodified_peptidoforms/covariance")

# Compute the correlation matrix
cor.mat <- cor(t(assay(obj.filter.ratio.multi.sc[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect")),
            method = "pearson")

# Calculate the p-values of the correlations
p.mat <- cor.mtest(t(assay(obj.filter.ratio.multi.sc[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect")), conf.level = 0.95)$p

# output
write.csv(cor.mat, "cor.mat.csv")
write.csv(p.mat, "p.mat.csv")

# plot correlation matrix
pdf("covariance_matrix.pdf",
    height = 15,
    width = 15)
corrplot(cor.mat, 
         method = "color",
         type = "full",
         order = "hclust",
         tl.pos = "lt",
         col = rev(COL2(diverging = c("RdBu"), n = 200)),
         tl.cex = 1,
         tl.col = "black",
         tl.offset = 0.3,
         p.mat = p.mat,  # Add p-value matrix
         sig.level = 0.05,  # Add significance level
         insig = "blank")  # Non-significant correlations are blank
dev.off()
```

### Cell level

#### PCA
- PC1 is correlated to total MS1
- TODO: Correlate to cell size and DAPI intensity
```{r}
dir.create("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/with_unmodified_peptidoforms/cells")
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/with_unmodified_peptidoforms/cells")

p <- pca(assay(obj.filter.ratio.multi.sc[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect"),
         metadata = colData(obj.filter.ratio.multi.sc),
         center = TRUE, 
         scale = TRUE)

pdf("MS1.ratio.log1p.batchCorrect_screeplot_cells.pdf",
    width = 5,
    height = 5)
screeplot(p,
          components = getComponents(p)[1:10])
dev.off()

pdf("MS1.ratio.log1p.batchCorrect_eigencor_cells.pdf",
    width = 5,
    height = 5)
eigencorplot(p,
             main = "Principle component correlations",
             cexMain = 1.5,
             metavars = c("replicate", "run_id", "total.ms1", "condition.predict"),
             col = viridis(100),
             colCorval = 'firebrick',
             fontCorval = 2,
             cexCorval = 0.5,
             rotLabX = 45,
             posColKey = 'top')
dev.off()

pdf("MS1.ratio.log1p.batchCorrect_replicate_pca_total_MS1_cells.pdf",
    width = 4,
    height = 5)
biplot(p,
       colby = "total.ms1",
       shape = "condition.predict",
       legendPosition = 'top',
       hline = 0, 
       vline = 0,
       lab = NULL) +
  scale_color_viridis_c() +
  labs(color = "Total MS1") +
  theme_Publication() +
  theme(legend.box="vertical",
        legend.margin=margin())
dev.off()

pdf("MS1.ratio.log1p.batchCorrect_replicate_pca_replicate_cells.pdf",
    width = 4,
    height = 5)
biplot(p,
       colby = "replicate", 
       shape = "condition.predict",
       legendPosition = 'top',
       hline = 0, 
       vline = 0,
       lab = NULL) +
  labs(color = "Replicate") +
  theme_Publication() +
  theme(legend.box="vertical", 
        legend.margin=margin())
dev.off()
```

#### Euclidean Distance
```{r}
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/with_unmodified_peptidoforms/cells")

control.dist <- as.vector(dist(t(assay(obj.filter.ratio.multi.sc[,obj.filter.ratio.multi.sc$condition.predict == "control"][["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect"))))
treat.dist <- as.vector(dist(t(assay(obj.filter.ratio.multi.sc[,obj.filter.ratio.multi.sc$condition.predict == "treat"][["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect"))))

df <- melt(makePaddedDataFrame(list(Control = control.dist,
                               Treat = treat.dist)))
df$variable <- factor(df$variable,
                      levels = c("Control", "Treat"))

pdf("euclidean_distance.pdf",
    height = 5,
    width = 5)
ggplot(df, aes(x = variable, y = value, fill = variable)) +
  geom_violin() +
  geom_boxplot(width=0.1, fill="white") +
  theme_Publication() +
  scale_fill_manual(values = c(Control = "#317ec2", 
                               Treat = "#c03830")) +
  labs(y = "Pairwise Euclidean Distance", fill = "Condition") +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
  stat_compare_means(aes(group = variable), 
                            method = "t.test", # Choose the appropriate test
                            label = "p.signif",
                            label.x.npc = "center",
                            label.y.npc = "top",
                            hide.ns = FALSE,
                            vjust = 1.5,
                     size = 5)
dev.off()
```

#### Cell-cell covariance
```{r}
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/with_unmodified_peptidoforms/cells")

# Compute the correlation matrix
cor.mat <- cor(assay(obj.filter.ratio.multi.sc[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect"),
            method = "pearson")

# Calculate the p-values of the correlations
p.mat <- cor.mtest(assay(obj.filter.ratio.multi.sc[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect"), conf.level = 0.95)$p

# output
write.csv(cor.mat, "cor.mat.csv")
write.csv(p.mat, "p.mat.csv")

# plot correlation matrix
pdf("covariance_matrix.pdf",
    height = 15,
    width = 15)
corrplot(cor.mat, 
         method = "color",
         type = "full",
         order = "hclust",
         tl.pos = "lt",
         #tl.col = all_colors[rownames(cor.mat)], # Apply color to labels based on row names
         col = rev(COL2(diverging = c("RdBu"), n = 200)),
         tl.cex = 1,
         tl.col = "black",
         tl.offset = 0.3,
         p.mat = p.mat,  # Add p-value matrix
         sig.level = 0.05,  # Add significance level
         insig = "blank")  # Non-significant correlations are blank
dev.off()
```

### Without unmodified peptidoforms
```{r}
# filter out unmodified
peptides <- rownames(obj.filter.ratio.multi.sc[["ptm.ratio"]])
peptides <- peptides[!(grepl("\\[un\\]", peptides) & !grepl("\\[(me|ac|me2|me3|su|hib)\\]", peptides))]
obj.filter.ratio.multi.sc.no_unmod <- obj.filter.ratio.multi.sc[rownames(obj.filter.ratio.multi.sc) %in% peptides,]

# make the histone ptms readable
rownames(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]]) <- ptm_readable_translation(rownames(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]]))
```

#### Peptidoform level

##### PCA
```{r}
dir.create("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms")
dir.create("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/pca")
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/pca")

p <- pca(t(assay(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect")),
         metadata = rowData(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]]),
         center = TRUE, 
         scale = TRUE)

pdf("MS1.ratio.log1p.batchCorrect_screeplot_peptidoform.pdf",
    width = 5,
    height = 5)
screeplot(p,
          components = getComponents(p)[1:10])
dev.off()

pdf("MS1.ratio.log1p.batchCorrect_eigencor_peptidoform.pdf",
    width = 5,
    height = 5)
eigencorplot(p,
             main = "Principle component correlations",
             cexMain = 1.5,
             metavars = c("Protein.Name", "Peptide.Sequence", "Precursor.Charge"),
             col = viridis(100),
             colCorval = 'firebrick',
             fontCorval = 2,
             cexCorval = 0.5,
             rotLabX = 45,
             posColKey = 'top')
dev.off()

pdf("MS1.ratio.log1p.batchCorrect_protein_pca_peptidoform.pdf",
    width = 7,
    height = 5)
biplot(p,
       colby = "Protein.Name", 
       hline = 0, 
       vline = 0,
       lab = NULL) +
  labs(color = "Protein") +
  theme_Publication() +
  theme(legend.position = "right",
        legend.direction = "vertical",
        legend.margin=margin())
dev.off()
```

##### Variance
- Positive relationship between variance and mean
- Log2 transform counts are more normally distributed
- polynomial regression when log transform counts
```{r}
dir.create("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/variance")
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/variance")

# get relative abundance
df <- assay(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect") %>%
  as.data.frame() %>%
  rownames_to_column("ptm") %>%
  pivot_longer(
    cols = -ptm, # This keeps the 'id' column fixed
    names_to = "variable",
    values_to = "value") %>%
  group_by(ptm) %>%
  summarize(mean = mean(value, na.rm = TRUE),
            mean.log1p = log1p(mean),
            variance = var(value, na.rm = TRUE),
            vmr = variance/mean) %>%
  merge(as.data.frame(rowData(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]])), by.x = "ptm", by.y = "row.names")
df$Protein.Name <- protein_readable_translation(df$Protein.Name)

# save
write.csv(df %>% select(-Fragment.Ions), 
          "MS1.ratio.log1p.batchCorrect_variance.csv",
          row.names = FALSE)

# plot variance
df.plot <- df[order(df$variance, decreasing = TRUE),] # order
df.plot$ptm <- factor(df.plot$ptm,
                      levels = rev(df.plot$ptm))

pdf("MS1.ratio.log1p.batchCorrect_variance_all.pdf",
    width = 6,
    height = 5)
ggplot(df.plot, aes(x=ptm, y=variance, fill=Protein.Name)) +
  geom_bar(stat="identity", width=0.95, position = position_dodge(width=1)) +
  geom_text(aes(label=ptm), vjust=0.5, hjust = -0.05, angle=0, position=position_dodge(width=1), size = 3) +
  coord_flip() +
  theme_Publication() +
  scale_fill_manual(values = protein_colors) +
  labs(y = "Variance",
       x = "Histone PTM",
       fill = "Protein") +
  theme(legend.position = "right",
      legend.direction = "vertical",
      legend.margin=margin(),
      axis.text.y=element_blank(),
      axis.ticks.y=element_blank()) +
  ylim(c(0, 0.03))
dev.off()

pdf("MS1.ratio.log1p.batchCorrect_variance_top_20.pdf",
    width = 6,
    height = 5)
ggplot(df.plot[1:20,], aes(x=ptm, y=variance, fill=Protein.Name)) +
  geom_bar(stat="identity", width=0.95, position = position_dodge(width=1)) +
  geom_text(aes(label=ptm), vjust=0.5, hjust = -0.05, angle=0, position=position_dodge(width=1), size = 3) +
  coord_flip() +
  theme_Publication() +
  scale_fill_manual(values = protein_colors) +
  labs(y = "Variance",
       x = "Histone PTM",
       fill = "Protein") +
  theme(legend.position = "right",
      legend.direction = "vertical",
      legend.margin=margin(),
      axis.text.y=element_blank(),
      axis.ticks.y=element_blank()) +
  ylim(c(0, 0.03))
dev.off()

# var vs mean
pdf("MS1.ratio.log1p.batchCorrect_mean_vs_variance.pdf",
    width = 7,
    height = 5)
ggplot(df, aes(x = mean, y = variance)) +
  geom_point(aes(color = Protein.Name)) +
  geom_smooth(method = "lm") +
  stat_cor() +
  theme_Publication() +
  labs(y = "Variance",
       x = "Mean Relative Abundance",
       color = "Protein") +
  theme(legend.position = "right",
      legend.direction = "vertical",
      legend.margin=margin())
dev.off()

# plot vmr
df.plot <- df[order(df$vmr, decreasing = TRUE),] # order
df.plot$ptm <- factor(df.plot$ptm,
                      levels = rev(df.plot$ptm))

pdf("MS1.ratio.log1p.batchCorrect_vmr_all.pdf",
    width = 6,
    height = 5)
ggplot(df.plot, aes(x=ptm, y=vmr, fill=Protein.Name)) +
  geom_bar(stat="identity", width=0.95, position = position_dodge(width=1)) +
  geom_text(aes(label=ptm), vjust=0.5, hjust = -0.05, angle=0, position=position_dodge(width=1), size = 3) +
  coord_flip() +
  theme_Publication() +
  scale_fill_manual(values = protein_colors) +
  labs(y = "Variance Mean Ratio",
       x = "Histone PTM",
       fill = "Protein") +
  theme(legend.position = "right",
      legend.direction = "vertical",
      legend.margin=margin(),
      axis.text.y=element_blank(),
      axis.ticks.y=element_blank()) +
  ylim(c(0,0.07))
dev.off()

pdf("MS1.ratio.log1p.batchCorrect_vmr_top_20.pdf",
    width = 6,
    height = 5)
ggplot(df.plot[1:20,], aes(x=ptm, y=vmr, fill=Protein.Name)) +
  geom_bar(stat="identity", width=0.95, position = position_dodge(width=1)) +
  geom_text(aes(label=ptm), vjust=0.5, hjust = -0.05, angle=0, position=position_dodge(width=1), size = 3) +
  coord_flip() +
  theme_Publication() +
  scale_fill_manual(values = protein_colors) +
  labs(y = "Variance Mean Ratio",
       x = "Histone PTM",
       fill = "Protein") +
  theme(legend.position = "right",
      legend.direction = "vertical",
      legend.margin=margin(),
      axis.text.y=element_blank(),
      axis.ticks.y=element_blank()) +
  ylim(c(0,0.07))
dev.off()

# vmr vs mean
pdf("MS1.ratio.log1p.batchCorrect_mean_vs_vmr.pdf",
    width = 7,
    height = 5)
ggplot(df, aes(x = mean, y = vmr)) +
  geom_point(aes(color = Protein.Name)) +
  geom_smooth(method = "lm") +
  stat_cor() +
  theme_Publication() +
  labs(y = "VMR",
       x = "Mean Relative Abundance",
       color = "Protein") +
  theme(legend.position = "right",
      legend.direction = "vertical",
      legend.margin=margin())
dev.off()

# var vs log2 mean
model <- lm(variance ~ poly(mean.log1p, 2, raw=TRUE), data=df)
coefficients <- coef(model)
equation <- sprintf("y = %.2f + %.2f*x + %.2f*x^2",
                    coefficients[1], coefficients[2], coefficients[3])
pdf("MS1.ratio.log1p.batchCorrect_mean.log1p_vs_variance.pdf",
    width = 7,
    height = 5)
ggplot(df, aes(x = mean.log1p, y = variance)) +
  geom_point(aes(color = Protein.Name)) +
  geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "blue") +
  stat_cor() +
  theme_Publication() +
  labs(y = "Variance",
       x = "Log2(Mean Relative Abundance)",
       color = "Protein") +
  theme(legend.position = "right",
      legend.direction = "vertical",
      legend.margin=margin()) +
  annotate("text", x = Inf, y = Inf, label = equation, hjust = 1.5, vjust = 5, size = 4, color = "black")
dev.off()

# vmr vs log2 mean
pdf("MS1.ratio.log1p.batchCorrect_mean.log1p_vs_vmr.pdf",
    width = 7,
    height = 5)
ggplot(df, aes(x = mean.log1p, y = vmr)) +
  geom_point(aes(color = Protein.Name)) +
  geom_smooth(method = "lm") +
  stat_cor() +
  theme_Publication() +
  labs(y = "VMR",
       x = "Log2(Mean Relative Abundance)",
       color = "Protein") +
  theme(legend.position = "right",
      legend.direction = "vertical",
      legend.margin=margin())
dev.off()
```

##### Coefficient of variation
- Inverse relationship between mean and CV^2
```{r}
dir.create("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/coefficient_of_variation")
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/coefficient_of_variation")

# get relative abundance
df <- assay(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect") %>%
  as.data.frame() %>%
  rownames_to_column("ptm") %>%
  pivot_longer(
    cols = -ptm, # This keeps the 'id' column fixed
    names_to = "variable",
    values_to = "value") %>%
  group_by(ptm) %>%
  summarize(mean = mean(value, na.rm = TRUE),
            cv = sd(value, na.rm = TRUE)/mean,
            cv.squared = cv^2) %>%
  merge(as.data.frame(rowData(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]])), by.x = "ptm", by.y = "row.names")
df$Protein.Name <- protein_readable_translation(df$Protein.Name)

# save
write.csv(df %>% select(-Fragment.Ions), 
          "MS1.ratio.log1p.batchCorrect_cv.csv",
          row.names = FALSE)

# plot cv
df.plot <- df[order(df$cv, decreasing = TRUE),] # order
df.plot$ptm <- factor(df.plot$ptm,
                      levels = rev(df.plot$ptm))

pdf("MS1.ratio.log1p.batchCorrect_cv_all.pdf",
    width = 7,
    height = 7)
ggplot(df.plot, aes(x=ptm, y=cv, fill=Protein.Name)) +
  geom_bar(stat="identity", width=0.95, position = position_dodge(width=1)) +
  geom_text(aes(label=ptm), vjust=0.5, hjust = -0.05, angle=0, position=position_dodge(width=1), size = 3) +
  coord_flip() +
  theme_Publication() +
  scale_fill_manual(values = protein_colors) +
  labs(y = "Coefficient of Variation",
       x = "Histone PTM",
       fill = "Protein") +
  theme(legend.position = "right",
      legend.direction = "vertical",
      legend.margin=margin(),
      axis.text.y=element_blank(),
      axis.ticks.y=element_blank()) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1), 
                     breaks = c(seq(0, 1.5, by = 0.25)),
                     limits = c(0, 1.3))
dev.off()

pdf("MS1.ratio.log1p.batchCorrect_cv_top_20.pdf",
    width = 6,
    height = 5)
ggplot(df.plot[1:20,], aes(x=ptm, y=cv, fill=Protein.Name)) +
  geom_bar(stat="identity", width=0.95, position = position_dodge(width=1)) +
  geom_text(aes(label=ptm), vjust=0.5, hjust = -0.05, angle=0, position=position_dodge(width=1), size = 3) +
  coord_flip() +
  theme_Publication() +
  scale_fill_manual(values = protein_colors) +
  labs(y = "Coefficient of Variation",
       x = "Histone PTM",
       fill = "Protein") +
  theme(legend.position = "right",
      legend.direction = "vertical",
      legend.margin=margin(),
      axis.text.y=element_blank(),
      axis.ticks.y=element_blank()) +
 scale_y_continuous(labels = scales::percent_format(accuracy = 1), 
                     breaks = c(seq(0, 1.5, by = 0.25)),
                     limits = c(0, 1.3))
dev.off()

# heatmap
column_ha = HeatmapAnnotation(Replicate = obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]]$replicate,
                              "Total MS1" = obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]]$total.ms1,
                              col = list(Replicate = c("1" = brewer.pal(3, "Set1")[1],
                                                       "2" = brewer.pal(3, "Set1")[2],
                                                       "3" = brewer.pal(3, "Set1")[3])))

mat <- assay(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect")
mat <- mat[match(df.plot$ptm, rownames(mat)),]

# Scale each row to have mean 0 and standard deviation 1
mat.scaled <- t(scale(t(mat), scale = TRUE, center = FALSE))

row_ha = rowAnnotation(CV = anno_barplot(df.plot$cv))

pdf("MS1.ratio.log1p.batchCorrect_cv_heatmap.pdf",
    width = 10,
    height = 10)
Heatmap(mat.scaled,
        top_annotation = column_ha,
        right_annotation = row_ha,
        heatmap_legend_param = list(title = "Scaled Relative Abundance"),
        cluster_rows = FALSE,
        cluster_columns = TRUE,
        show_column_names = FALSE,
        row_names_gp = gpar(fontsize = 10))
dev.off()

# cv vs mean
pdf("MS1.ratio.log1p.batchCorrect_mean_vs_cv.pdf",
    width = 6,
    height = 5)
ggplot(df, aes(x = mean, y = cv)) +
  geom_point(aes(color = Protein.Name)) +
  geom_smooth(method = "lm", color = "blue") +
  stat_cor() +
  theme_Publication() +
  scale_color_manual(values = protein_colors) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1), breaks = c(seq(0, 1.5, by = 0.25))) +
  labs(y = "Coefficient of Variation",
       x = "Mean Relative Abundance",
       color = "Protein") +
  theme(legend.position = "right",
      legend.direction = "vertical",
      legend.margin=margin())
  # annotate("text", x = Inf, y = Inf, label = equation, hjust = 1.5, vjust = 5, size = 4, color = "black")
dev.off()

# cv vs log2 mean
# model <- lm(cv.squared ~ poly(mean.log1p, 2, raw=TRUE), data=df)
# coefficients <- coef(model)
# equation <- sprintf("y = %.2f + %.2f*x + %.2f*x^2",
#                     coefficients[1], coefficients[2], coefficients[3])
# pdf("MS1.ratio.log1p.batchCorrect_mean.log1p_vs_cv.pdf",
#     width = 7,
#     height = 5)
# ggplot(df, aes(x = mean.log1p, y = cv)) +
#   geom_point(aes(color = Protein.Name)) +
#   geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "blue") +
#   stat_cor() +
#   theme_Publication() +
#   scale_y_continuous(labels = scales::percent_format(accuracy = 1), breaks = c(seq(0, 1.5, by = 0.25))) +
#   labs(y = "Coefficient of Variation",
#        x = "Log2(Mean Relative Abundance)",
#        color = "Protein") +
#   theme(legend.position = "right",
#       legend.direction = "vertical",
#       legend.margin=margin())+
#   annotate("text", x = Inf, y = Inf, label = equation, hjust = 1.5, vjust = 5, size = 4, color = "black")
# dev.off()

# plot cv2
df.plot <- df[order(df$cv.squared, decreasing = TRUE),] # order
df.plot$ptm <- factor(df.plot$ptm,
                      levels = rev(df.plot$ptm))

pdf("MS1.ratio.log1p.batchCorrect_cv2_all.pdf",
    width = 6,
    height = 5)
ggplot(df.plot, aes(x=ptm, y=cv.squared, fill=Protein.Name)) +
  geom_bar(stat="identity", width=0.95, position = position_dodge(width=1)) +
  geom_text(aes(label=ptm), vjust=0.5, hjust = -0.05, angle=0, position=position_dodge(width=1), size = 3) +
  coord_flip() +
  theme_Publication() +
  scale_fill_manual(values = protein_colors) +
  labs(y = "Coefficient of Variation Squared",
       x = "Histone PTM",
       fill = "Protein") +
  theme(legend.position = "right",
      legend.direction = "vertical",
      legend.margin=margin(),
      axis.text.y=element_blank(),
      axis.ticks.y=element_blank()) +
  ylim(c(0, 1.4))
dev.off()

pdf("MS1.ratio.log1p.batchCorrect_cv2_top_20.pdf",
    width = 6,
    height = 5)
ggplot(df.plot[1:20,], aes(x=ptm, y=cv.squared, fill=Protein.Name)) +
  geom_bar(stat="identity", width=0.95, position = position_dodge(width=1)) +
  geom_text(aes(label=ptm), vjust=0.5, hjust = -0.05, angle=0, position=position_dodge(width=1), size = 3) +
  coord_flip() +
  theme_Publication() +
  scale_fill_manual(values = protein_colors) +
  labs(y = "Coefficient of Variation Squared",
       x = "Histone PTM",
       fill = "Protein") +
  theme(legend.position = "right",
      legend.direction = "vertical",
      legend.margin=margin(),
      axis.text.y=element_blank(),
      axis.ticks.y=element_blank())  +
  ylim(c(0, 1.4))
dev.off()

# cv2 vs mean
model <- lm(cv.squared ~ poly(mean, 2, raw=TRUE), data=df)
coefficients <- coef(model)
equation <- sprintf("y = %.2f + %.2f*x + %.2f*x^2",
                    coefficients[1], coefficients[2], coefficients[3])
pdf("MS1.ratio.log1p.batchCorrect_mean_vs_cv2.pdf",
    width = 7,
    height = 5)
ggplot(df, aes(x = mean, y = cv.squared)) +
  geom_point(aes(color = Protein.Name)) +
  geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "blue") +
  stat_cor() +
  theme_Publication() +
  labs(y = "Coefficient of Variation Squared",
       x = "Mean Relative Abundance",
       color = "Protein") +
  theme(legend.position = "right",
      legend.direction = "vertical",
      legend.margin=margin()) +
  annotate("text", x = Inf, y = Inf, label = equation, hjust = 1.5, vjust = 5, size = 4, color = "black")
dev.off()

# cv2 vs log2 mean
# model <- lm(cv.squared ~ poly(mean.log1p, 2, raw=TRUE), data=df)
# coefficients <- coef(model)
# equation <- sprintf("y = %.2f + %.2f*x + %.2f*x^2",
#                     coefficients[1], coefficients[2], coefficients[3])
# pdf("MS1.ratio.log1p.batchCorrect_mean.log1p_vs_cv2.pdf",
#     width = 7,
#     height = 5)
# ggplot(df, aes(x = mean.log1p, y = cv.squared)) +
#   geom_point(aes(color = Protein.Name)) +
#   geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "blue") +
#   stat_cor() +
#   theme_Publication() +
#   labs(y = "Coefficient of Variation Squared",
#        x = "Log2(Mean Relative Abundance)",
#        color = "Protein") +
#   theme(legend.position = "right",
#       legend.direction = "vertical",
#       legend.margin=margin()) +
#   annotate("text", x = Inf, y = Inf, label = equation, hjust = 1.5, vjust = 5, size = 4, color = "black")
# dev.off()
```

###### Treat vs Control
```{r}
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/coefficient_of_variation")

df <- assay(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect") %>%
  as.data.frame() %>%
  rownames_to_column("ptm") %>%
  pivot_longer(
    cols = -ptm, # This keeps the 'id' column fixed
    names_to = "variable",
    values_to = "value") %>%
  merge(as.data.frame(colData(obj.filter.ratio.multi.sc.no_unmod)), by.x = "variable", by.y = "row.names") %>%
  group_by(condition.predict, ptm) %>%
  summarize(mean = mean(value, na.rm = TRUE),
            cv = sd(value, na.rm = TRUE)/mean)

df$condition.predict <- factor(df$condition.predict,
                      levels = c("control", "treat"))

pdf("treat_vs_control_cv.pdf",
    height = 4,
    width = 3)
ggplot(df, aes(x = condition.predict, y = cv, fill = condition.predict)) +
  geom_violin() +
  geom_boxplot(width=0.25, fill="white") +
  theme_Publication() +
  scale_fill_manual(values = c(control = "#317ec2",
                               treat = "#c03830"),
                    labels = c("Control",
                               "Treat")) +
  labs(y = "Coefficient of Variation", fill = "Condition") +
  # theme(axis.title.x=element_blank(),
  #       axis.text.x=element_blank(),
  #       axis.ticks.x=element_blank()) +
  stat_compare_means(aes(group = condition.predict), 
                            method = "t.test", # Choose the appropriate test
                            label = "p.format",
                            label.x.npc = "center",
                            label.y.npc = "top",
                            hide.ns = FALSE,
                            vjust = 1.5,
                     size = 5)
dev.off()
```

##### Beta regession
- Beta regression is particularly well-suited for modeling data that are bounded between 0 and 1, such as proportions, percentages, and relative abundances. This statistical method assumes that the dependent variable is distributed according to a Beta distribution, which can handle the typical skewness and heteroscedasticity observed in bounded data more effectively than traditional linear regression.
- It does not look like this model apprpriate fits the data
```{r, eval = FALSE}
dir.create("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/beta_regression")
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/beta_regression")

# get relative abundance
df <- assay(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]], "MS1.ratio.log1p") %>%
  as.data.frame() %>%
  rownames_to_column("ptm") %>%
  pivot_longer(
    cols = -ptm, # This keeps the 'id' column fixed
    names_to = "variable",
    values_to = "value") %>%
  merge(as.data.frame(colData(obj.filter.ratio.multi.sc.no_unmod)), by.x = "variable", by.y = "row.names")


# check if values are between 0-1
range(df$value)

# Fit beta regression
# including batch as a fixed effect - systematic effects
model <- betareg(value ~ 1 + ptm + replicate, data = df) 
summary(model)

# Plotting fitted values vs. residuals
# should be randomly distributed
df$residuals <- residuals(model, type = "pearson")

pdf("MS1.ratio.log1p.batchCorrect_beta_regression_residuals.pdf",
    width = 5,
    height = 5)
ggplot(df, aes(x = fitted(model), y = residuals)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  labs(title = "Residuals vs. Fitted", x = "Fitted Values", y = "Residuals")
dev.off()

# Checking normality of residuals
pdf("MS1.ratio.log1p.batchCorrect_beta_distribution_residuals.pdf",
    width = 5,
    height = 5)
hist(residuals(model, type = "pearson"), breaks = 20, main = "Histogram of Residuals")
dev.off()

# Generating a Q-Q plot for residuals
pdf("MS1.ratio.log1p.batchCorrect_beta_regression_qq.pdf",
    width = 5,
    height = 5)
qqnorm(df$residuals)
qqline(df$residuals, col = "steelblue")
dev.off()
```

##### Linear regession
- It looks like this model fits the data a bit better
```{r, eval = FALSE}
dir.create("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/linear_regression")
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/linear_regression")

# get relative abundance
df <- assay(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]], "MS1.ratio.log1p") %>%
  as.data.frame() %>%
  rownames_to_column("ptm") %>%
  pivot_longer(
    cols = -ptm, # This keeps the 'id' column fixed
    names_to = "variable",
    values_to = "value") %>%
  merge(as.data.frame(colData(obj.filter.ratio.multi.sc.no_unmod)), by.x = "variable", by.y = "row.names")


# check if values are between 0-1
range(df$value)

# Fit beta regression
# including batch as a fixed effect - systematic effects
model <- glm(log2(value) ~ ptm + replicate, data = df) 
summary(model)

# Plotting fitted values vs. residuals
# should be randomly distributed
df$residuals <- residuals(model, type = "pearson")

pdf("MS1.ratio.log1p.batchCorrect_linear_regression_residuals.pdf",
    width = 5,
    height = 5)
ggplot(df, aes(x = fitted(model), y = residuals)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  labs(title = "Residuals vs. Fitted", x = "Fitted Values", y = "Residuals")
dev.off()

# Checking normality of residuals
pdf("MS1.ratio.log1p.batchCorrect_linear_distribution_residuals.pdf",
    width = 5,
    height = 5)
hist(residuals(model, type = "pearson"), breaks = 20, main = "Histogram of Residuals")
dev.off()

# Generating a Q-Q plot for residuals
pdf("MS1.ratio.log1p.batchCorrect_linear_regression_qq.pdf",
    width = 5,
    height = 5)
qqnorm(df$residuals)
qqline(df$residuals, col = "steelblue")
dev.off()

ptm_variability <- df %>%
  group_by(ptm) %>%
  summarise(
    Mean_Residual = mean(residuals),
    SD_Residual = sd(residuals),
    Count = n()
  ) %>%
  arrange(desc(SD_Residual))

# plot
# coefficients <- coef(model)
# equation <- sprintf("y = %.2f + %.2f*x + %.2f*x^2",
#                     coefficients[1], coefficients[2], coefficients[3])
pdf("MS1.ratio.log1p.batchCorrect_linear_regression_mean_vs_residual.pdf",
    width = 7,
    height = 5)
ggplot(ptm_variability, aes(x = Mean_Residual, y = SD_Residual)) +
  geom_point() +
  geom_smooth(method = "lm") +
  stat_cor() +
  theme_Publication() +
  labs(y = "Residual",
       x = "Mean",
       color = "Protein") +
  theme(legend.position = "right",
      legend.direction = "vertical",
      legend.margin=margin()) 
dev.off()
```


##### PTM-PTM covariance

###### All
```{r}
dir.create("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/peptidoform")
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/peptidoform")

# Compute the correlation matrix
cor.mat.all <- cor(t(assay(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect")),
            method = "pearson")

# # Perform hierarchical clustering
# dist.mat <- dist(cor.mat.all)
# hc <- hclust(dist.mat)

# Calculate the p-values of the correlations
p.mat.all <- cor.mtest(t(assay(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect")), conf.level = 0.95)$p

# Order the matrix according to hierarchical clustering
order.hc.all <- corrMatOrder(cor.mat.all,
                                order = "hclust")
cor.mat.all <- cor.mat.all[order.hc.all, order.hc.all]
p.mat.all <- p.mat.all[order.hc.all, order.hc.all]

# # set protein colors
# rowdata <- rowData(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]])
# rowdata$Protein.Name <- protein_readable_translation(rowdata$Protein.Name)
# rowdata <- rowdata[match(rownames(cor .mat.all), rownames(rowdata)),]
# 
# # Reorder Protein.Names according to hierarchical clustering order
# rowdata <- rowdata[hc$order, ]

# Create a color vector matched to the reordered labels
#protein_color_map <- setNames(protein_colors, rowdata$Protein.Name)  # Ensure protein_color_map exists

# Output matrices
write.csv(cor.mat.all, "cor.mat.all.csv")
write.csv(p.mat.all, "p.mat.all.csv")

# Plot correlation matrix
pdf("control+treat_covariance_matrix.pdf", 
    height = 10, 
    width = 10,
    bg = "transparent")
corrplot(cor.mat.all, 
         method = "color",
         type = "upper",
         order = "original",  # Ensure clustering order matches the row order used
         tl.pos = "td",
         #tl.col = protein_colors[rowdata$Protein.Name],  # Apply color to labels based on row names
         tl.col = "black",
         col = rev(COL2(diverging = c("RdBu"), n = 200)),
         tl.cex = 1,
         tl.offset = 0.3,
         p.mat = p.mat.all,  # Add p-value matrix
         sig.level = 0.05,  # Add significance level
         insig = "blank",
         diag = FALSE)  # Non-significant correlations are blank
dev.off()
```

###### Control
```{r}
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/peptidoform")

# Compute the correlation matrix
cor.mat.control <- cor(t(assay(obj.filter.ratio.multi.sc.no_unmod[,obj.filter.ratio.multi.sc.no_unmod$condition.predict == "control"][["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect")),
            method = "pearson")

# # Perform hierarchical clustering
# dist.mat <- dist(cor.mat.control)
# hc <- hclust(dist.mat)

# Calculate the p-values of the correlations
p.mat.contol <- cor.mtest(t(assay(obj.filter.ratio.multi.sc.no_unmod[,obj.filter.ratio.multi.sc.no_unmod$condition.predict == "control"][["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect")), conf.level = 0.95)$p

# Order the matrix according to hierarchical clustering
order.hc.control <- corrMatOrder(cor.mat.control,
                                order = "hclust")
cor.mat.control <- cor.mat.control[order.hc.control, order.hc.control]
p.mat.contol <- p.mat.contol[order.hc.control, order.hc.control]
diag(p.mat.contol) <- 1

# get just lower half of matrix for pvalues
p.mat.contol.lower <- p.mat.contol
p.mat.contol.lower[upper.tri(p.mat.contol.lower)] <- NA

# # set protein colors
# rowdata <- rowData(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]])
# rowdata$Protein.Name <- protein_readable_translation(rowdata$Protein.Name)
# rowdata <- rowdata[match(rownames(cor.mat.control), rownames(rowdata)),]
# 
# # Reorder Protein.Names according to hierarchical clustering order
# rowdata <- rowdata[hc$order, ]

# Create a color vector matched to the reordered labels
#protein_color_map <- setNames(protein_colors, rowdata$Protein.Name)  # Ensure protein_color_map exists

# Output matrices
write.csv(cor.mat.control, "control.cor.mat.control.csv")
write.csv(p.mat.contol, "control.p.mat.csv")
write.csv(p.mat.contol.lower, "control.p.mat.lower.csv", na = "")

# Plot correlation matrix
pdf("control_covariance_matrix.pdf", height = 10, width = 10)
corrplot(cor.mat.control, 
         mar = c(1, 1, 1, 1),
         method = "color",
         type = "lower",
         order = "original",  # Ensure clustering order matches the row order used
         tl.pos = "ld",
         #tl.col = protein_colors[rowdata$Protein.Name],  # Apply color to labels based on row names
         tl.col = "black",
         col = rev(COL2(diverging = c("RdBu"), n = 200)),
         tl.cex = 1,
         tl.offset = 0.3,
         p.mat = p.mat.contol,  # Add p-value matrix
         sig.level = 0.05,  # Add significance level
         insig = "blank",
         diag = FALSE)  # Non-significant correlations are blank
dev.off()

pdf("control_covariance_matrix_pub.pdf", height = 10, width = 10)
corrplot(cor.mat.control, 
         method = "color",
         type = "lower",
         order = "original",  # Ensure clustering order matches the row order used
         tl.pos = "l",
         cl.pos = "n",
         #tl.col = protein_colors[rowdata$Protein.Name],  # Apply color to labels based on row names
         tl.col = "black",
         col = rev(COL2(diverging = c("RdBu"), n = 200)),
         tl.cex = 1,
         tl.offset = 0.3,
         p.mat = p.mat.contol,  # Add p-value matrix
         sig.level = 0.05,  # Add significance level
         insig = "blank",
         diag = TRUE)  # Non-significant correlations are blank
dev.off()
```



###### Treat
```{r}
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/peptidoform")

# Compute the correlation matrix
cor.mat.treat <- cor(t(assay(obj.filter.ratio.multi.sc.no_unmod[,obj.filter.ratio.multi.sc.no_unmod$condition.predict == "treat"][["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect")),
            method = "pearson")

# # Perform hierarchical clustering
# dist.mat <- dist(cor.mat.treat)
# hc <- hclust(dist.mat)

# Calculate the p-values of the correlations
p.mat.treat <- cor.mtest(t(assay(obj.filter.ratio.multi.sc.no_unmod[,obj.filter.ratio.multi.sc.no_unmod$condition.predict == "treat"][["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect")), conf.level = 0.95)$p

# Order the matrix according to hierarchical clustering in control
cor.mat.treat <- cor.mat.treat[order.hc.control, order.hc.control]
p.mat.treat <- p.mat.treat[order.hc.control, order.hc.control]
diag(p.mat.treat) <- 1

# get just lower half of matrix for pvalues
p.mat.treat.upper <- p.mat.treat
p.mat.treat.upper[lower.tri(p.mat.treat.upper)] <- NA

# # set protein colors
# rowdata <- rowData(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]])
# rowdata$Protein.Name <- protein_readable_translation(rowdata$Protein.Name)
# rowdata <- rowdata[match(rownames(cor.mat.treat), rownames(rowdata)),]
# 
# # Reorder Protein.Names according to hierarchical clustering order
# rowdata <- rowdata[hc$order, ]

# Create a color vector matched to the reordered labels
#protein_color_map <- setNames(protein_colors, rowdata$Protein.Name)  # Ensure protein_color_map exists

# Output matrices
write.csv(cor.mat.treat, "treat.cor.mat.treat.csv")
write.csv(p.mat.treat, "treat.p.mat.csv")
write.csv(p.mat.treat.upper, "treat.p.mat.lower.csv", na = "")

# Plot correlation matrix
pdf("treat_covariance_matrix.pdf", height = 10, width = 10)
corrplot(cor.mat.treat, 
         method = "color",
         type = "upper",
         order = "original",  # Ensure clustering order matches the row order used
         tl.pos = "td",
         #tl.col = protein_colors[rowdata$Protein.Name],  # Apply color to labels based on row names
         tl.col = "black",
         col = rev(COL2(diverging = c("RdBu"), n = 200)),
         tl.cex = 1,
         tl.offset = 0.3,
         p.mat = p.mat.treat,  # Add p-value matrix
         sig.level = 0.05,  # Add significance level
         insig = "blank",
         diag = FALSE)  # Non-significant correlations are blank
dev.off()

# this one has diaganols
pdf("treat_covariance_matrix_pub.pdf", height = 10, width = 10)
corrplot(cor.mat.treat, 
         method = "color",
         type = "upper",
         order = "original",  # Ensure clustering order matches the row order used
         tl.pos = "t",
         cl.pos = "n",
         #tl.col = protein_colors[rowdata$Protein.Name],  # Apply color to labels based on row names
         tl.col = "black",
         col = rev(COL2(diverging = c("RdBu"), n = 200)),
         tl.cex = 1,
         tl.offset = 0.3,
         p.mat = p.mat.treat,  # Add p-value matrix
         sig.level = 0.05,  # Add significance level
         insig = "blank",
         diag = TRUE)  # Non-significant correlations are blank
dev.off()
```

###### Compare Treat vs Control Correlation matrices
```{r}
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/peptidoform")

# test if correlation matrices are significantly different
library(vegan)
mantel_test <- mantel(cor.mat.control, cor.mat.treat, permutations=10000)
mantel_results <- data.frame(
  Mantel_Statistic = mantel_test$statistic,
  Significance = mantel_test$signif,
  Method = mantel_test$method,
  Number_of_Permutations = mantel_test$permutations
)
write.csv(mantel_results, "treat_vs_control_cor.mat_mantel_test.csv")

# compute the fold difference matrix
cor.mat.fold <- log2((cor.mat.treat + 1) / (cor.mat.control + 1))

data_matrix <- assay(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect")
set.seed(123)  # Setting a seed for reproducibility
num_iterations <- 10000  # Number of times to perform the sampling
control_size <- 43    # Number of samples in the control group
treatment_size <- 29   # Number of samples in the treatment group
log2_fold_changes <- vector("list", num_iterations)

# Loop to perform the random sampling
for (i in 1:num_iterations) {
  # Sample column indices randomly
  sampled_indices <- sample(ncol(data_matrix), control_size + treatment_size)
  
  # Split indices into control and treatment groups
  control_indices <- sampled_indices[1:control_size]
  treatment_indices <- sampled_indices[(control_size + 1):(control_size + treatment_size)]
  
  # Extract the corresponding columns for control and treatment groups
  control_matrix <- data_matrix[, control_indices]
  treatment_matrix <- data_matrix[, treatment_indices]
  
  # Calculate correlation matrices
  control_cor <- cor(t(control_matrix))
  treatment_cor <- cor(t(treatment_matrix))
  
  # Calculate fold changes
  log2_fold_changes[[i]] <- log2((treatment_cor + 1) / (control_cor + 1))
}

# Number of matrices in the list
num_matrices <- length(log2_fold_changes)

# Dimensions of one matrix (assuming all matrices are the same size)
num_rows <- nrow(log2_fold_changes[[1]])
num_cols <- ncol(log2_fold_changes[[1]])

# Initialize a matrix to store p-values
p_value_matrix <- matrix(0, num_rows, num_cols, dimnames = dimnames(log2_fold_changes[[1]]))

# Loop over each element in the matrix
for (i in 1:num_rows) {
  for (j in 1:num_cols) {
    # Collect the values from the same position across all matrices
    null_distribution <- sapply(log2_fold_changes, function(x) x[i, j])
    
    # Observed value at the same position
    observed_value <- cor.mat.fold[i, j]
    
    # Calculate two-sided p-value
    extreme_high <- sum(null_distribution >= observed_value) / num_matrices
    extreme_low <- sum(null_distribution <= observed_value) / num_matrices
    p_value_matrix[i, j] <- 2 * min(extreme_high, extreme_low)
  }
}

# Order the matrix according to hierarchical clustering in control
p_value_matrix <- p_value_matrix[order.hc.control, order.hc.control]

# multiple testing correction
# Flatten the matrix to a vector
p_values_vector <- as.vector(p_value_matrix)

# Adjust the p-values using the Benjamini-Hochberg method
adjusted_p_values_vector <- p.adjust(p_values_vector, method = "BH")

# Reshape the adjusted p-values vector back to a matrix
adjusted_p_values_matrix <- matrix(adjusted_p_values_vector, nrow = nrow(p_value_matrix), ncol = ncol(p_value_matrix))

# Assign row and column names to the adjusted p-values matrix
rownames(adjusted_p_values_matrix) <- rownames(p_value_matrix)
colnames(adjusted_p_values_matrix) <- colnames(p_value_matrix)

# get just lower half of matrix for log2FC
cor.mat.fold.upper <- cor.mat.fold
cor.mat.fold.upper[lower.tri(cor.mat.fold.upper)] <- NA

# get just lower half of matrix for pvalues
p.mat.fold.upper <- adjusted_p_values_matrix
p.mat.fold.upper[lower.tri(p.mat.fold.upper)] <- NA

# Output matrices
write.csv(cor.mat.fold.upper, "treat_vs_control_log2fc.cor.mat.csv", na = "")
write.csv(p.mat.fold.upper, "treat_vs_control.p.mat.csv", na = "")

# Plot the difference matrix
pdf("treat_vs_control_foldChange_matrix.pdf", 
    height = 10, 
    width = 10)
corrplot(cor.mat.fold, 
         is.corr = FALSE,
         method = "square",
         type = "upper",
         order = "original",
         tl.pos = "td",
         #tl.col = protein_colors[rowdata$Protein.Name],  # Apply color to labels based on row names
         tl.col = "black",
         col = rev(COL2(diverging = c("RdBu"), n = 200)),
         col.lim = c(-2, 2),
         tl.cex = 1,
         tl.offset = 0.3,
         p.mat = adjusted_p_values_matrix,  # Add p-value matrix
         sig.level = 0.05,  # Add significance level
         insig = "blank",
         diag = TRUE)  
dev.off()

# Convert the matrix to a dataframe
cor.mat.fold.df <- melt(cor.mat.fold)
colnames(cor.mat.fold.df) <- c("hPTM1", "hPTM2", "Log2FoldChange")
cor.mat.fold.df$pvalue <- melt(p_value_matrix)$value
cor.mat.fold.df <- cor.mat.fold.df[order(cor.mat.fold.df$pvalue), ] # Sort by pvalue

write.csv(cor.mat.fold.df, "treat_vs_control.csv", row.names = FALSE)

# distribution of significant foldchanges
pdf("treat_vs_control_foldChange_distribution.pdf", 
    height = 4, 
    width = 4)
ggplot(subset(cor.mat.fold.df, pvalue < 0.05), aes(x=Log2FoldChange)) + 
 geom_histogram(colour="black", fill="white") +
 theme_Publication() +
 geom_vline(xintercept = 0,
            linetype = "dashed",
            color = "red") +
  labs(x = "Log2 fold change",
       y = "Frequency")
dev.off()

# compare significant pearon R 
df <- melt(makePaddedDataFrame(list(Control = cor.mat.control[p.mat.contol < 0.05],
                               Treat = cor.mat.treat[p.mat.treat < 0.05])))
pdf("treat_vs_control_foldChange_R_values.pdf",
    height = 4,
    width = 3)
ggplot(df, aes(x = variable, y = value, fill = variable)) +
  geom_violin() +
  geom_boxplot(width=0.1, fill="white") +
  theme_Publication() +
  scale_fill_manual(values = c(Control = "#317ec2", 
                               Treat = "#c03830")) +
  labs(y = "Pairwise Euclidean Distance", fill = "Condition") +
  stat_compare_means(aes(group = variable), 
                            method = "t.test", # Choose the appropriate test
                            label = "p.signif",
                            label.x.npc = "center",
                            label.y.npc = "top",
                            hide.ns = FALSE,
                            vjust = 1.5,
                     size = 5)
dev.off()
```

###### Extract examples from comparison
- Plot H3K4me vs H4K5acK16ac or H4K8acK16ac or H4K5acK12acK16ac
```{r}
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/peptidoform")

df <- assay(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect") %>%
  t() %>%
  as.data.frame() %>%
  select(H3K4me, H4K5acK16ac, H4K8acK16ac, H4K5acK12acK16ac) %>%
  merge(as.data.frame(colData(obj.filter.ratio.multi.sc.no_unmod)), by.x = "row.names", by.y = "row.names")
    
# H3K4me vs H4K8acK16ac
pdf("H3K4me_vs_H4K5acK16ac_scatter_control.pdf", 
    height = 4, 
    width = 4)
ggplot(subset(df, condition.predict == "control"), aes(x = H3K4me, y = H4K5acK16ac)) +
  geom_point(color = "#317ec2") +
  geom_smooth(method = "lm", color = "#317ec2") +
  stat_cor() +
  theme_Publication() +
  labs(x = "H3K4me\nRelative Abundance",
       y = "H4K5acK16ac\nRelative Abundance",
       subtitle = "Control") +
  theme(legend.position = "none")
dev.off()

pdf("H3K4me_vs_H4K5acK16ac_scatter_treat.pdf", 
    height = 4, 
    width = 4)
ggplot(subset(df, condition.predict == "treat"), aes(x = H3K4me, y = H4K5acK16ac)) +
  geom_point(color = "#c03830") +
  geom_smooth(method = "lm", color = "#c03830") +
  stat_cor() +
  theme_Publication() +
  labs(x = "H3K4me\nRelative Abundance",
       y = "H4K5acK16ac\nRelative Abundance",
       subtitle = "Treat") +
  theme(legend.position = "none")
dev.off()

# H3K4me vs H4K8acK16ac
pdf("H3K4me_vs_H4K8acK16ac_scatter_control.pdf", 
    height = 4, 
    width = 4)
ggplot(subset(df, condition.predict == "control"), aes(x = H3K4me, y = H4K8acK16ac)) +
  geom_point(color = "#317ec2") +
  geom_smooth(method = "lm", color = "#317ec2") +
  stat_cor() +
  theme_Publication() +
  labs(x = "H3K4me\nRelative Abundance",
       y = "H4K8acK16ac\nRelative Abundance",
       subtitle = "Control") +
  theme(legend.position = "none")
dev.off()

pdf("H3K4me_vs_H4K8acK16ac_scatter_treat.pdf", 
    height = 4, 
    width = 4)
ggplot(subset(df, condition.predict == "treat"), aes(x = H3K4me, y = H4K8acK16ac)) +
  geom_point(color = "#c03830") +
  geom_smooth(method = "lm", color = "#c03830") +
  stat_cor() +
  theme_Publication() +
  labs(x = "H3K4me\nRelative Abundance",
       y = "H4K8acK16ac\nRelative Abundance",
       subtitle = "Treat") +
  theme(legend.position = "none")
dev.off()

# # H3K4me vs H4K5acK12acK16ac
# pdf("H3K4me_vs_H4K5acK12acK16ac_scatter_control.pdf", 
#     height = 4, 
#     width = 4)
# ggplot(subset(df, condition.predict == "control"), aes(x = H3K4me, y = H4K5acK12acK16ac)) +
#   geom_point(color = "#317ec2") +
#   geom_smooth(method = "lm", color = "#317ec2") +
#   stat_cor() +
#   theme_Publication() +
#   labs(x = "H3K4me\nRelative Abundance",
#        y = "H4K8acK16ac\nRelative Abundance",
#        subtitle = "Control") +
#   theme(legend.position = "none")
# dev.off()
# 
# pdf("H3K4me_vs_H4K5acK12acK16ac_scatter_treat.pdf", 
#     height = 4, 
#     width = 4)
# ggplot(subset(df, condition.predict == "treat"), aes(x = H3K4me, y = H4K5acK12acK16ac)) +
#   geom_point(color = "#c03830") +
#   geom_smooth(method = "lm", color = "#c03830") +
#   stat_cor() +
#   theme_Publication() +
#   labs(x = "H3K4me\nRelative Abundance",
#        y = "H4K8acK16ac\nRelative Abundance",
#        subtitle = "Treat") +
#   theme(legend.position = "none")
# dev.off()
```

###### Extract modules for comparison
Module in control group:
  H3K9acK14ac
  H4K8acK12acK16ac
  H4K5acK16ac
  H4K8acK16ac
  H4K5acK8acK16ac
  H4K5acK8acK12acK16ac
  H4K5acK12acK16ac
```{r}
module <- c("H3K9acK14ac", "H4K8acK12acK16ac", "H4K5acK16ac", "H4K8acK16ac", "H4K5acK8acK16ac", "H4K5acK8acK12acK16ac", "H4K5acK12acK16ac")

control.module <- cor.mat.control[module, module]
upper_matrix[lower.tri(upper_matrix)] <- NA
control.module <- control.module[upper_matrix]

pdf("treat_vs_control_foldChange_R_values.pdf",
    height = 4,
    width = 3)
ggplot(df, aes(x = variable, y = value, fill = variable)) +
  geom_violin() +
  geom_boxplot(width=0.1, fill="white") +
  theme_Publication() +
  scale_fill_manual(values = c(Control = "#317ec2", 
                               Treat = "#c03830")) +
  labs(y = "Pairwise Euclidean Distance", fill = "Condition") +
  stat_compare_means(aes(group = variable), 
                            method = "t.test", # Choose the appropriate test
                            label = "p.signif",
                            label.x.npc = "center",
                            label.y.npc = "top",
                            hide.ns = FALSE,
                            vjust = 1.5,
                     size = 5)
dev.off()
```


#### Cell level

##### PCA
- PC1 is correlated to total MS1
- TODO: Correlate to cell size and DAPI intensity
```{r}
dir.create("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/cells")
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/cells")

p <- pca(assay(obj.filter.ratio.multi.sc.no_unmod[["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect"),
         metadata = colData(obj.filter.ratio.multi.sc.no_unmod),
         center = TRUE, 
         scale = TRUE)

pdf("MS1.ratio.log1p.batchCorrect_screeplot_cells.pdf",
    width = 5,
    height = 5)
screeplot(p,
          components = getComponents(p)[1:10])
dev.off()

pdf("MS1.ratio.log1p.batchCorrect_eigencor_cells.pdf",
    width = 5,
    height = 5)
eigencorplot(p,
             main = "Principle component correlations",
             cexMain = 1.5,
             metavars = c("replicate", "run_id", "total.ms1"),
             col = viridis(100),
             colCorval = 'firebrick',
             fontCorval = 2,
             cexCorval = 0.5,
             rotLabX = 45,
             posColKey = 'top')
dev.off()

pdf("MS1.ratio.log1p.batchCorrect_pca.pdf",
    width = 4,
    height = 5)
biplot(p,
       colby = "condition.predict", 
       legendPosition = 'top',
       hline = 0, 
       vline = 0,
       lab = NULL,
       encircle = TRUE,
       encircleFillKey = c("control" = "#317ec2",
                                "treat" = "#c03830"),
       encircleAlpha = 0.2) +
  labs(color = "Condition") +
  theme_Publication() +
  theme(legend.box="vertical", 
        legend.margin=margin()) +
  scale_color_manual(values = c("control" = "#317ec2",
                                "treat" = "#c03830"),
                     labels = c("Control",
                                "Treated"))
dev.off()
```

##### Euclidean Distance
```{r}
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/cells")

control.dist <- as.vector(dist(t(assay(obj.filter.ratio.multi.sc.no_unmod[,obj.filter.ratio.multi.sc.no_unmod$condition.predict == "control"][["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect"))))
treat.dist <- as.vector(dist(t(assay(obj.filter.ratio.multi.sc.no_unmod[,obj.filter.ratio.multi.sc.no_unmod$condition.predict == "treat"][["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect"))))

df <- melt(makePaddedDataFrame(list(Control = control.dist,
                               Treat = treat.dist)))
df$variable <- factor(df$variable,
                      levels = c("Control", "Treat"))

pdf("euclidean_distance.pdf",
    height = 4,
    width = 3)
ggplot(df, aes(x = variable, y = value, fill = variable)) +
  geom_violin() +
  geom_boxplot(width=0.1, fill="white") +
  theme_Publication() +
  scale_fill_manual(values = c(Control = "#317ec2", 
                               Treat = "#c03830")) +
  labs(y = "Pairwise Euclidean Distance", fill = "Condition") +
  # theme(axis.title.x=element_blank(),
  #       axis.text.x=element_blank(),
  #       axis.ticks.x=element_blank()) +
  stat_compare_means(aes(group = variable), 
                            method = "t.test", # Choose the appropriate test
                            label = "p.signif",
                            label.x.npc = "center",
                            label.y.npc = "top",
                            hide.ns = FALSE,
                            vjust = 1.5,
                     size = 5)
dev.off()
```

##### Cell-cell covariance

##### Control
```{r}
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/cells")

# Compute the correlation matrix
cor.mat <- cor(assay(obj.filter.ratio.multi.sc.no_unmod[,obj.filter.ratio.multi.sc.no_unmod$condition.predict == "control"][["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect"),
            method = "pearson")

# Calculate the p-values of the correlations
p.mat <- cor.mtest(assay(obj.filter.ratio.multi.sc.no_unmod[,obj.filter.ratio.multi.sc.no_unmod$condition.predict == "control"][["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect"), conf.level = 0.95)$p

# output
write.csv(cor.mat, "control.cor.mat.csv")
write.csv(p.mat, "control.p.mat.csv")

# plot correlation matrix
pdf("control_covariance_matrix.pdf",
    height = 15,
    width = 15)
corrplot(cor.mat, 
         method = "color",
         type = "full",
         order = "hclust",
         tl.pos = "lt",
         #tl.col = all_colors[rownames(cor.mat)], # Apply color to labels based on row names
         col = rev(COL2(diverging = c("RdBu"), n = 200)),
         tl.cex = 1,
         tl.col = "black",
         tl.offset = 0.3,
         p.mat = p.mat,  # Add p-value matrix
         sig.level = 0.05,  # Add significance level
         insig = "blank")  # Non-significant correlations are blank
dev.off()
```

##### Treat
```{r}
setwd("/Users/ronaldcutler/Dropbox (EinsteinMed)/Sidoli-lab/Projects/Single-cell-histone/Analysis/7-biological-variability/auto+nabut/with_technical_variation/without_unmodified_peptidoforms/cells")

# Compute the correlation matrix
cor.mat <- cor(assay(obj.filter.ratio.multi.sc.no_unmod[,obj.filter.ratio.multi.sc.no_unmod$condition.predict == "treat"][["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect"),
            method = "pearson")

# Calculate the p-values of the correlations
p.mat <- cor.mtest(assay(obj.filter.ratio.multi.sc.no_unmod[,obj.filter.ratio.multi.sc.no_unmod$condition.predict == "treat"][["ptm.ratio"]], "MS1.ratio.log1p.batchCorrect"), conf.level = 0.95)$p

# output
write.csv(cor.mat, "treat.cor.mat.csv")
write.csv(p.mat, "treat.p.mat.csv")

# plot correlation matrix
pdf("treat_covariance_matrix.pdf",
    height = 15,
    width = 15)
corrplot(cor.mat, 
         method = "color",
         type = "full",
         order = "hclust",
         tl.pos = "lt",
         #tl.col = all_colors[rownames(cor.mat)], # Apply color to labels based on row names
         col = rev(COL2(diverging = c("RdBu"), n = 200)),
         tl.cex = 1,
         tl.col = "black",
         tl.offset = 0.3,
         p.mat = p.mat,  # Add p-value matrix
         sig.level = 0.05,  # Add significance level
         insig = "blank")  # Non-significant correlations are blank
dev.off()
```
